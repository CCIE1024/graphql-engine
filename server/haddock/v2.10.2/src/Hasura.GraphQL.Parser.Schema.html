<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE PatternSynonyms #-}</span><span>
</span><span id="line-2"></span><span>
</span><span id="line-3"></span><span class="hs-comment">-- | Types for representing a GraphQL schema.</span><span>
</span><span id="line-4"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Hasura.GraphQL.Parser.Schema</span><span>
</span><span id="line-5"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-comment">-- * Kinds</span></span><span>
</span><span id="line-6"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Kind"><span class="hs-identifier">Kind</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-7"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#%3A%3C%3A"><span class="hs-operator">(:&lt;:)</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-8"></span><span>    </span><span class="hs-keyword">type</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#%3C%3A"><span class="hs-operator">(&lt;:)</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-9"></span><span>
</span><span id="line-10"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Types</span></span><span>
</span><span id="line-11"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Nullability"><span class="hs-identifier">Nullability</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-12"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier">Type</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-13"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#onTypeDef"><span class="hs-identifier">onTypeDef</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-14"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeInfo"><span class="hs-identifier">TypeInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIScalar"><span class="hs-identifier">TIScalar</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIEnum"><span class="hs-identifier">TIEnum</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIInputObject"><span class="hs-identifier">TIInputObject</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIObject"><span class="hs-identifier">TIObject</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIInterface"><span class="hs-identifier">TIInterface</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIUnion"><span class="hs-identifier">TIUnion</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-15"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#getTypeInfo"><span class="hs-identifier">getTypeInfo</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-16"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#SomeDefinitionTypeInfo"><span class="hs-identifier">SomeDefinitionTypeInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-17"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#eqType"><span class="hs-identifier">eqType</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-18"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#eqTypeInfo"><span class="hs-identifier">eqTypeInfo</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-19"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#typeNullability"><span class="hs-identifier">typeNullability</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-20"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#nullableType"><span class="hs-identifier">nullableType</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-21"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#nonNullableType"><span class="hs-identifier">nonNullableType</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-22"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#toGraphQLType"><span class="hs-identifier">toGraphQLType</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-23"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#getObjectInfo"><span class="hs-identifier">getObjectInfo</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-24"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#getInterfaceInfo"><span class="hs-identifier">getInterfaceInfo</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-25"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#EnumValueInfo"><span class="hs-identifier">EnumValueInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-26"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputFieldInfo"><span class="hs-identifier">InputFieldInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-27"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#FieldInfo"><span class="hs-identifier">FieldInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-28"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputObjectInfo"><span class="hs-identifier">InputObjectInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputObjectInfo"><span class="hs-identifier">InputObjectInfo</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-29"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ObjectInfo"><span class="hs-identifier">ObjectInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ObjectInfo"><span class="hs-identifier">ObjectInfo</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#oiFields"><span class="hs-identifier">oiFields</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#oiImplements"><span class="hs-identifier">oiImplements</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-30"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InterfaceInfo"><span class="hs-identifier">InterfaceInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InterfaceInfo"><span class="hs-identifier">InterfaceInfo</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#iiFields"><span class="hs-identifier">iiFields</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#iiPossibleTypes"><span class="hs-identifier">iiPossibleTypes</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-31"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#UnionInfo"><span class="hs-identifier">UnionInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#UnionInfo"><span class="hs-identifier">UnionInfo</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#uiPossibleTypes"><span class="hs-identifier">uiPossibleTypes</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-32"></span><span>
</span><span id="line-33"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Definitions</span></span><span>
</span><span id="line-34"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier">Definition</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-35"></span><span>
</span><span id="line-36"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Schemas</span></span><span>
</span><span id="line-37"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Schema"><span class="hs-identifier">Schema</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-38"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ConflictingDefinitions"><span class="hs-identifier">ConflictingDefinitions</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-39"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#HasTypeDefinitions"><span class="hs-identifier">HasTypeDefinitions</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-40"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeDefinitionsWrapper"><span class="hs-identifier">TypeDefinitionsWrapper</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-41"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#collectTypeDefinitions"><span class="hs-identifier">collectTypeDefinitions</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-42"></span><span>
</span><span id="line-43"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Miscellany</span></span><span>
</span><span id="line-44"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#DirectiveInfo"><span class="hs-identifier">DirectiveInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-45"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-46"></span><span class="hs-keyword">where</span><span>
</span><span id="line-47"></span><span>
</span><span id="line-48"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Lens</span></span><span>
</span><span id="line-49"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Except</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">ExceptT</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">MonadError</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">runExcept</span></span><span class="hs-special">)</span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Reader</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">MonadReader</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">ReaderT</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-51"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.State.Strict</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">MonadState</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">StateT</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">execStateT</span></span><span class="hs-special">)</span><span>
</span><span id="line-52"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Foldable</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">traverse_</span></span><span class="hs-special">)</span><span>
</span><span id="line-53"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Function</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">on</span></span><span class="hs-special">)</span><span>
</span><span id="line-54"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Functor.Classes</span></span><span>
</span><span id="line-55"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.HashMap.Strict</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">HashMap</span></span><span class="hs-special">)</span><span>
</span><span id="line-56"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.HashMap.Strict</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Map</span></span><span>
</span><span id="line-57"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Hashable</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Hashable</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-58"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.List</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">List</span></span><span>
</span><span id="line-59"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.List.NonEmpty</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">NonEmpty</span></span><span class="hs-special">)</span><span>
</span><span id="line-60"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.List.NonEmpty</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">NE</span></span><span>
</span><span id="line-61"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Text</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">T</span></span><span>
</span><span id="line-62"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Void</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Void</span></span><span class="hs-special">)</span><span>
</span><span id="line-63"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Generics</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-64"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../file:///workdir/dist-newstyle/build/x86_64-linux/ghc-8.10.7/hasura-error-message-1.0.0/opt/doc/html/hasura-error-message/src"><span class="hs-identifier">Hasura.Base.ErrorMessage</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///workdir/dist-newstyle/build/x86_64-linux/ghc-8.10.7/hasura-error-message-1.0.0/opt/doc/html/hasura-error-message/src"><span class="hs-identifier">toErrorMessage</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-65"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../file:///workdir/dist-newstyle/build/x86_64-linux/ghc-8.10.7/hasura-error-message-1.0.0/opt/doc/html/hasura-error-message/src"><span class="hs-identifier">Hasura.Base.ToErrorValue</span></a></span><span>
</span><span id="line-66"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Names.html"><span class="hs-identifier">Hasura.GraphQL.Parser.Names</span></a></span><span>
</span><span id="line-67"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Language.GraphQL.Draft.Syntax</span></span><span>
</span><span id="line-68"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">Description</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-69"></span><span>    </span><span class="annot"><span class="hs-identifier">DirectiveLocation</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-70"></span><span>    </span><span class="annot"><span class="hs-identifier">GType</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-71"></span><span>    </span><span class="annot"><span class="hs-identifier">Name</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-72"></span><span>    </span><span class="annot"><span class="hs-identifier">Value</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-73"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-74"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Language.GraphQL.Draft.Syntax</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">G</span></span><span>
</span><span id="line-75"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Prelude</span></span><span>
</span><span id="line-76"></span><span>
</span><span id="line-77"></span><span class="hs-comment">-- | GraphQL types are divided into two classes: input types and output types.</span><span>
</span><span id="line-78"></span><span class="hs-comment">-- The GraphQL spec does not use the word &#8220;kind&#8221; to describe these classes, but</span><span>
</span><span id="line-79"></span><span class="hs-comment">-- it&#8217;s an apt term.</span><span>
</span><span id="line-80"></span><span class="hs-comment">--</span><span>
</span><span id="line-81"></span><span class="hs-comment">-- Some GraphQL types can be used at either kind, so we also include the 'Both'</span><span>
</span><span id="line-82"></span><span class="hs-comment">-- kind, the superkind of both 'Input' and 'Output'. The '&lt;:' class provides</span><span>
</span><span id="line-83"></span><span class="hs-comment">-- kind subsumption constraints.</span><span>
</span><span id="line-84"></span><span class="hs-comment">--</span><span>
</span><span id="line-85"></span><span class="hs-comment">-- For more details, see &lt;http://spec.graphql.org/June2018/#sec-Input-and-Output-Types&gt;.</span><span>
</span><span id="line-86"></span><span class="hs-keyword">data</span><span> </span><span id="Kind"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Kind"><span class="hs-identifier hs-var">Kind</span></a></span></span><span>
</span><span id="line-87"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- | see Note [The 'Both kind]</span><span>
</span><span id="line-88"></span><span>    </span><span id="Both"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Both"><span class="hs-identifier hs-var">Both</span></a></span></span><span>
</span><span id="line-89"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Input"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Input"><span class="hs-identifier hs-var">Input</span></a></span></span><span>
</span><span id="line-90"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Output"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Output"><span class="hs-identifier hs-var">Output</span></a></span></span><span>
</span><span id="line-91"></span><span>
</span><span id="line-92"></span><span class="hs-comment">{- Note [The 'Both kind]
~~~~~~~~~~~~~~~~~~~~~~~~
As described in the Haddock comments for Kind and &lt;:, we use Kind to index
various types, such as Type and Parser. We use this to enforce various
correctness constraints mandated by the GraphQL spec; for example, we don&#8217;t
allow input object fields to have output types and we don&#8217;t allow output object
fields to have input types.

But scalars and enums can be used as input types *or* output types. A natural
encoding of that in Haskell would be to make constructors for those types
polymorphic, like this:

    data Kind = Input | Output

    data TypeInfo k where
      TIScalar      :: TypeInfo k           -- \ Polymorphic!
      TIEnum        :: ... -&gt; TypeInfo k    -- /
      TIInputObject :: ... -&gt; TypeInfo origin 'Input
      TIObject      :: ... -&gt; TypeInfo origin 'Output

Naturally, this would give the `scalar` parser constructor a similarly
polymorphic type:

    scalar
      :: MonadParse m
      =&gt; Name
      -&gt; Maybe Description
      -&gt; ScalarRepresentation a
      -&gt; Parser k m a             -- Polymorphic!

But if we actually try that, we run into problems. The trouble is that we want
to use the Kind to influence several different things:

  * As mentioned above, we use it to ensure that the types we generate are
    well-kinded according to the GraphQL spec rules.

  * We use it to determine what a Parser consumes as input. Parsers for input
    types parse GraphQL input values, but Parsers for output types parse
    selection sets. (See Note [The meaning of Parser 'Output] in
    Hasura.GraphQL.Parser.Internal.Parser for an explanation of why.)

  * We use it to know when to expect a sub-selection set for a field of an
    output object (see Note [The delicate balance of GraphQL kinds]).

These many uses of Kind cause some trouble for a polymorphic representation. For
example, consider our `scalar` parser constructor above---if we were to
instantiate it at kind 'Output, we&#8217;d receive a `Parser 'Output`, which we would
then expect to be able to apply to a selection set. But that doesn&#8217;t make any
sense, since scalar fields don&#8217;t have selection sets!

Another issue with this representation has to do with effectful parser
constructors (such as constructors that can throw errors). These have types like

    mkFooParser :: MonadSchema n m =&gt; Blah -&gt; m (Parser k n Foo)

where the parser construction is itself monadic. This causes some annoyance,
since even if mkFooParser returns a Parser of a polymorphic kind, code like this
will not typecheck:

    (fooParser :: forall k. Parser k n Foo) &lt;- mkFooParser blah

The issue is that we have to instantiate k to a particular type to be able to
call mkFooParser. If we want to use the result at both kinds, we&#8217;d have to call
mkFooParser twice:

    (fooInputParser :: Parser 'Input n Foo) &lt;- mkFooParser blah
    (fooOutputParser :: Parser 'Output n Foo) &lt;- mkFooParser blah

Other situations encounter similar difficulties, and they are not easy to
resolve without impredicative polymorphism (which GHC does not support).

To avoid this problem, we don&#8217;t use polymorphic kinds, but instead introduce a
form of kind subsumption. Types that can be used as both input and output types
are explicitly given the kind 'Both. This allows us to get the best of both
worlds:

  * We use the &lt;: typeclass to accept 'Both in most places where we expect
    either input or output types.

  * We can treat 'Both specially to avoid requiring `scalar` to supply a
    selection set parser (see Note [The delicate balance of GraphQL kinds] for
    further explanation).

  * Because we avoid the polymorphism, we don&#8217;t run into the aforementioned
    issue with monadic parser constructors.

All of this is subtle and somewhat complicated, but unfortunately there isn&#8217;t
much of a way around that: GraphQL is subtle and complicated. Our use of an
explicit 'Both kind isn&#8217;t the only way to encode these things, but it&#8217;s the
particular set of compromises we&#8217;ve chosen to accept.

Note [The delicate balance of GraphQL kinds]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
As discussed in Note [The 'Both kind], we use GraphQL kinds to distinguish
several different things. One of them is which output types take sub-selection
sets. For example, scalars don&#8217;t accept sub-selection sets, so if we have a
schema like

    type Query {
      users: [User!]!
    }

    type User {
      id: Int!
    }

then the following query is illegal:

    query {
      users {
        id {
          blah
        }
      }
    }

The id field has a scalar type, so it should not take a sub-selection set. This
is actually something we care about distinguishing at the type level, because it
affects the type of the `selection` parser combinator. Suppose we have a
`Parser 'Output m UserQuery` for the User type. When we parse a field with that
type, we expect to receive a UserQuery as a result, unsurprisingly. But what if
we parse an output field using the `int` parser, which has this type:

    int :: MonadParse m =&gt; Parser 'Both m Int32

If we follow the same logic as for the User parser above, we&#8217;d expect to receive
an Int32 as a result... but that doesn&#8217;t make any sense, since the Int32
corresponds to the result *we* are suppose to produce as a result of executing
the query, not something user-specified.

One way to solve this would be to associate every Parser with two result types:
one when given an input object, and one when given a selection set. Then our
parsers could be given these types, instead:

    user :: MonadParse m =&gt; Parser 'Output m Void UserQuery
    int :: MonadParse m =&gt; Parser 'Both m Int32 ()

But if you work through this, you&#8217;ll find that *all* parsers will either have
Void or () for at least one of their input result types or their output result
types, depending on their kind:

  * All 'Input parsers must have Void for their output result type, since they
    aren&#8217;t allowed to be used in output contexts at all.

  * All 'Output parsers must have Void for their input result type, since they
    aren&#8217;t allowed to be used in input contexts at all.

  * That just leaves 'Both. The only types of kind 'Both are scalars and enums,
    neither of which accept a sub-selection set. Their output result type would
    therefore be (), since they are allowed to appear in output contexts, but
    they don&#8217;t return any results.

The end result of this is that we clutter all our types with Voids and ()s, with
little actual benefit.

If you really think about it, the fact that the no types of kind 'Both accept a
sub-selection set is really something of a coincidence. In theory, one could
imagine a future version of the GraphQL spec adding a type that can be used as
both an input type or an output type, but accepts a sub-selection set. If that
ever happens, we&#8217;ll have to tweak our encoding, but for now, we can take
advantage of this happy coincidence and make the kinds serve double duty:

  * We can make `ParserInput 'Both` identical to `ParserInput 'Input`, since
    all parsers of kind 'Both only parse input values.

  * We can require types of kind 'Both in `selection`, which does not expect a
    sub-selection set, and types of kind 'Output in `subselection`, which does.

Relying on this coincidence might seem a little gross, and perhaps it is
somewhat. But it&#8217;s enormously convenient: not doing this would make some types
significantly more complicated, since we would have to thread around more
information at the type level and we couldn&#8217;t make as many simplifying
assumptions. So until GraphQL adds a type that violates these assumptions, we
are happy to take advantage of this coincidence. -}</span><span>
</span><span id="line-266"></span><span>
</span><span id="line-267"></span><span class="hs-comment">-- | Evidence for '&lt;:'.</span><span>
</span><span id="line-268"></span><span class="hs-keyword">data</span><span> </span><span id="local-6989586621689361910"><span class="annot"><a href="#local-6989586621689361910"><span class="hs-identifier hs-type">k1</span></a></span></span><span> </span><span id="%3A%3C%3A"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#%3A%3C%3A"><span class="hs-operator hs-var">:&lt;:</span></a></span></span><span> </span><span id="local-6989586621689361909"><span class="annot"><a href="#local-6989586621689361909"><span class="hs-identifier hs-type">k2</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-269"></span><span>  </span><span id="local-6989586621689362344"><span id="KRefl"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#KRefl"><span class="hs-identifier hs-var">KRefl</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621689362344"><span class="hs-identifier hs-type">k</span></a></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#%3A%3C%3A"><span class="hs-operator hs-type">:&lt;:</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362344"><span class="hs-identifier hs-type">k</span></a></span></span><span>
</span><span id="line-270"></span><span>  </span><span id="local-6989586621689361907"><span id="KBoth"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#KBoth"><span class="hs-identifier hs-var">KBoth</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621689361907"><span class="hs-identifier hs-type">k</span></a></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#%3A%3C%3A"><span class="hs-operator hs-type">:&lt;:</span></a></span><span> </span><span class="hs-special">'</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Both"><span class="hs-identifier hs-type">Both</span></a></span></span><span>
</span><span id="line-271"></span><span>
</span><span id="line-272"></span><span class="hs-comment">-- | 'Kind' subsumption. The GraphQL kind hierarchy is extremely simple:</span><span>
</span><span id="line-273"></span><span class="hs-comment">--</span><span>
</span><span id="line-274"></span><span class="hs-comment">-- &gt;     Both</span><span>
</span><span id="line-275"></span><span class="hs-comment">-- &gt;     /  \</span><span>
</span><span id="line-276"></span><span class="hs-comment">-- &gt; Input  Output</span><span>
</span><span id="line-277"></span><span class="hs-comment">--</span><span>
</span><span id="line-278"></span><span class="hs-comment">-- Various functions in this module use '&lt;:' to allow 'Both' to be used in</span><span>
</span><span id="line-279"></span><span class="hs-comment">-- places where 'Input' or 'Output' would otherwise be expected.</span><span>
</span><span id="line-280"></span><span class="hs-keyword">class</span><span> </span><span id="local-6989586621689362346"><span class="annot"><a href="#local-6989586621689362346"><span class="hs-identifier hs-type">k1</span></a></span></span><span> </span><span id="%3C%3A"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#%3C%3A"><span class="hs-operator hs-var">&lt;:</span></a></span></span><span> </span><span id="local-6989586621689362345"><span class="annot"><a href="#local-6989586621689362345"><span class="hs-identifier hs-type">k2</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-281"></span><span>  </span><span id="subKind"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#subKind"><span class="hs-identifier hs-type">subKind</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621689362346"><span class="hs-identifier hs-type">k1</span></a></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#%3A%3C%3A"><span class="hs-operator hs-type">:&lt;:</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362345"><span class="hs-identifier hs-type">k2</span></a></span><span>
</span><span id="line-282"></span><span>
</span><span id="line-283"></span><span id="local-6989586621689361903"><span id="local-6989586621689361904"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="#local-6989586621689361904"><span class="hs-identifier hs-type">k1</span></a></span><span> </span><span class="annot"><span class="hs-glyph hs-type">~</span></span><span> </span><span class="annot"><a href="#local-6989586621689361903"><span class="hs-identifier hs-type">k2</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621689361904"><span class="hs-identifier hs-type">k1</span></a></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#%3C%3A"><span class="hs-operator hs-type">&lt;:</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361903"><span class="hs-identifier hs-type">k2</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-284"></span><span>  </span><span id="local-6989586621689361900"><span class="annot"><span class="annottext">subKind :: k1 :&lt;: k2
</span><a href="#local-6989586621689361900"><span class="hs-identifier hs-var hs-var hs-var hs-var">subKind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">k1 :&lt;: k2
forall (k :: Kind). k :&lt;: k
</span><a href="Hasura.GraphQL.Parser.Schema.html#KRefl"><span class="hs-identifier hs-var">KRefl</span></a></span></span></span><span>
</span><span id="line-285"></span><span>
</span><span id="line-286"></span><span id="local-6989586621689361899"><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span> </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="#local-6989586621689361899"><span class="hs-identifier hs-type">k</span></a></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#%3C%3A"><span class="hs-operator hs-type">&lt;:</span></a></span><span> </span><span class="hs-special">'</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Both"><span class="hs-identifier hs-type">Both</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-287"></span><span>  </span><span id="local-6989586621689361897"><span class="annot"><span class="annottext">subKind :: k :&lt;: 'Both
</span><a href="#local-6989586621689361897"><span class="hs-identifier hs-var hs-var hs-var hs-var">subKind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">k :&lt;: 'Both
forall (k :: Kind). k :&lt;: 'Both
</span><a href="Hasura.GraphQL.Parser.Schema.html#KBoth"><span class="hs-identifier hs-var">KBoth</span></a></span></span><span>
</span><span id="line-288"></span><span>
</span><span id="line-289"></span><span class="hs-keyword">data</span><span> </span><span id="Nullability"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Nullability"><span class="hs-identifier hs-var">Nullability</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Nullable"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Nullable"><span class="hs-identifier hs-var">Nullable</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="NonNullable"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#NonNullable"><span class="hs-identifier hs-var">NonNullable</span></a></span></span><span>
</span><span id="line-290"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621689361891"><span id="local-6989586621689361893"><span class="annot"><span class="annottext">Nullability -&gt; Nullability -&gt; Bool
(Nullability -&gt; Nullability -&gt; Bool)
-&gt; (Nullability -&gt; Nullability -&gt; Bool) -&gt; Eq Nullability
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Nullability -&gt; Nullability -&gt; Bool
$c/= :: Nullability -&gt; Nullability -&gt; Bool
== :: Nullability -&gt; Nullability -&gt; Bool
$c== :: Nullability -&gt; Nullability -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-291"></span><span>
</span><span id="line-292"></span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#isNullable"><span class="hs-identifier hs-type">isNullable</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Nullability"><span class="hs-identifier hs-type">Nullability</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-293"></span><span id="isNullable"><span class="annot"><span class="annottext">isNullable :: Nullability -&gt; Bool
</span><a href="Hasura.GraphQL.Parser.Schema.html#isNullable"><span class="hs-identifier hs-var hs-var">isNullable</span></a></span></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><a href="Hasura.GraphQL.Parser.Schema.html#Nullable"><span class="hs-identifier hs-var">Nullable</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-294"></span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#isNullable"><span class="hs-identifier hs-var">isNullable</span></a></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><a href="Hasura.GraphQL.Parser.Schema.html#NonNullable"><span class="hs-identifier hs-var">NonNullable</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-295"></span><span>
</span><span id="line-296"></span><span class="hs-keyword">data</span><span> </span><span id="Type"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-var">Type</span></a></span></span><span> </span><span id="local-6989586621689362328"><span class="annot"><a href="#local-6989586621689362328"><span class="hs-identifier hs-type">origin</span></a></span></span><span> </span><span id="local-6989586621689362327"><span class="annot"><a href="#local-6989586621689362327"><span class="hs-identifier hs-type">k</span></a></span></span><span>
</span><span id="line-297"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="TNamed"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TNamed"><span class="hs-identifier hs-var">TNamed</span></a></span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Nullability"><span class="hs-identifier hs-type">Nullability</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362328"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeInfo"><span class="hs-identifier hs-type">TypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362328"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362327"><span class="hs-identifier hs-type">k</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-298"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TList"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TList"><span class="hs-identifier hs-var">TList</span></a></span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Nullability"><span class="hs-identifier hs-type">Nullability</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362328"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362327"><span class="hs-identifier hs-type">k</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-299"></span><span>
</span><span id="line-300"></span><span id="local-6989586621689361885"><span id="local-6989586621689361886"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621689361882"><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361886"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361885"><span class="hs-identifier hs-type">k</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-301"></span><span>  </span><span id="local-6989586621689361881"><span class="annot"><span class="annottext">== :: Type origin k -&gt; Type origin k -&gt; Bool
</span><span class="hs-operator hs-var hs-var hs-var hs-var">(==)</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type origin k -&gt; Type origin k -&gt; Bool
forall origin (k1 :: Kind) (k2 :: Kind).
Type origin k1 -&gt; Type origin k2 -&gt; Bool
</span><a href="Hasura.GraphQL.Parser.Schema.html#eqType"><span class="hs-identifier hs-var">eqType</span></a></span></span></span><span>
</span><span id="line-302"></span><span>
</span><span id="line-303"></span><span class="hs-comment">-- | Adjust the 'Definition' underlying a 'Type'</span><span>
</span><span id="line-304"></span><span id="local-6989586621689362325"><span id="local-6989586621689362326"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#onTypeDef"><span class="hs-identifier hs-type">onTypeDef</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621689362332"><span class="annot"><a href="#local-6989586621689362332"><span class="hs-identifier hs-type">a</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362326"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362332"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362326"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362332"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362326"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362325"><span class="hs-identifier hs-type">k</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362326"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362325"><span class="hs-identifier hs-type">k</span></a></span></span></span><span>
</span><span id="line-305"></span><span id="onTypeDef"><span class="annot"><span class="annottext">onTypeDef :: (forall a. Definition origin a -&gt; Definition origin a)
-&gt; Type origin k -&gt; Type origin k
</span><a href="Hasura.GraphQL.Parser.Schema.html#onTypeDef"><span class="hs-identifier hs-var hs-var">onTypeDef</span></a></span></span><span> </span><span id="local-6989586621689361880"><span class="annot"><span class="annottext">forall a. Definition origin a -&gt; Definition origin a
</span><a href="#local-6989586621689361880"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TNamed"><span class="hs-identifier hs-type">TNamed</span></a></span><span> </span><span id="local-6989586621689361879"><span class="annot"><span class="annottext">Nullability
</span><a href="#local-6989586621689361879"><span class="hs-identifier hs-var">nul</span></a></span></span><span> </span><span id="local-6989586621689361878"><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
</span><a href="#local-6989586621689361878"><span class="hs-identifier hs-var">def</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Nullability
-&gt; Definition origin (TypeInfo origin k) -&gt; Type origin k
forall origin (k :: Kind).
Nullability
-&gt; Definition origin (TypeInfo origin k) -&gt; Type origin k
</span><a href="Hasura.GraphQL.Parser.Schema.html#TNamed"><span class="hs-identifier hs-var">TNamed</span></a></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><a href="#local-6989586621689361879"><span class="hs-identifier hs-var">nul</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
-&gt; Definition origin (TypeInfo origin k)
forall a. Definition origin a -&gt; Definition origin a
</span><a href="#local-6989586621689361880"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
</span><a href="#local-6989586621689361878"><span class="hs-identifier hs-var">def</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-306"></span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#onTypeDef"><span class="hs-identifier hs-var">onTypeDef</span></a></span><span> </span><span id="local-6989586621689361877"><span class="annot"><span class="annottext">forall a. Definition origin a -&gt; Definition origin a
</span><a href="#local-6989586621689361877"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TList"><span class="hs-identifier hs-type">TList</span></a></span><span> </span><span id="local-6989586621689361876"><span class="annot"><span class="annottext">Nullability
</span><a href="#local-6989586621689361876"><span class="hs-identifier hs-var">nul</span></a></span></span><span> </span><span id="local-6989586621689361875"><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361875"><span class="hs-identifier hs-var">typ</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Nullability -&gt; Type origin k -&gt; Type origin k
forall origin (k :: Kind).
Nullability -&gt; Type origin k -&gt; Type origin k
</span><a href="Hasura.GraphQL.Parser.Schema.html#TList"><span class="hs-identifier hs-var">TList</span></a></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><a href="#local-6989586621689361876"><span class="hs-identifier hs-var">nul</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(forall a. Definition origin a -&gt; Definition origin a)
-&gt; Type origin k -&gt; Type origin k
forall origin (k :: Kind).
(forall a. Definition origin a -&gt; Definition origin a)
-&gt; Type origin k -&gt; Type origin k
</span><a href="Hasura.GraphQL.Parser.Schema.html#onTypeDef"><span class="hs-identifier hs-var">onTypeDef</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Definition origin a -&gt; Definition origin a
</span><a href="#local-6989586621689361877"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361875"><span class="hs-identifier hs-var">typ</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-307"></span><span>
</span><span id="line-308"></span><span class="hs-comment">-- | Like '==', but can compare 'Type's of different kinds.</span><span>
</span><span id="line-309"></span><span id="local-6989586621689362334"><span id="local-6989586621689362335"><span id="local-6989586621689362336"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#eqType"><span class="hs-identifier hs-type">eqType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362336"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362335"><span class="hs-identifier hs-type">k1</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362336"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362334"><span class="hs-identifier hs-type">k2</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span></span><span>
</span><span id="line-310"></span><span id="eqType"><span class="annot"><span class="annottext">eqType :: Type origin k1 -&gt; Type origin k2 -&gt; Bool
</span><a href="Hasura.GraphQL.Parser.Schema.html#eqType"><span class="hs-identifier hs-var hs-var">eqType</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TNamed"><span class="hs-identifier hs-type">TNamed</span></a></span><span> </span><span id="local-6989586621689361874"><span class="annot"><span class="annottext">Nullability
</span><a href="#local-6989586621689361874"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621689361873"><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k1)
</span><a href="#local-6989586621689361873"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TNamed"><span class="hs-identifier hs-type">TNamed</span></a></span><span> </span><span id="local-6989586621689361872"><span class="annot"><span class="annottext">Nullability
</span><a href="#local-6989586621689361872"><span class="hs-identifier hs-var">n'</span></a></span></span><span> </span><span id="local-6989586621689361871"><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k2)
</span><a href="#local-6989586621689361871"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Nullability
</span><a href="#local-6989586621689361874"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Nullability -&gt; Nullability -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><a href="#local-6989586621689361872"><span class="hs-identifier hs-var">n'</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">(TypeInfo origin k1 -&gt; TypeInfo origin k2 -&gt; Bool)
-&gt; Definition origin (TypeInfo origin k1)
-&gt; Definition origin (TypeInfo origin k2)
-&gt; Bool
forall (f :: * -&gt; *) a b.
Eq1 f =&gt;
(a -&gt; b -&gt; Bool) -&gt; f a -&gt; f b -&gt; Bool
</span><span class="hs-identifier hs-var">liftEq</span></span><span> </span><span class="annot"><span class="annottext">TypeInfo origin k1 -&gt; TypeInfo origin k2 -&gt; Bool
forall origin (k1 :: Kind) (k2 :: Kind).
TypeInfo origin k1 -&gt; TypeInfo origin k2 -&gt; Bool
</span><a href="Hasura.GraphQL.Parser.Schema.html#eqTypeInfo"><span class="hs-identifier hs-var">eqTypeInfo</span></a></span><span> </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k1)
</span><a href="#local-6989586621689361873"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k2)
</span><a href="#local-6989586621689361871"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-311"></span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#eqType"><span class="hs-identifier hs-var">eqType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TList"><span class="hs-identifier hs-type">TList</span></a></span><span> </span><span id="local-6989586621689361868"><span class="annot"><span class="annottext">Nullability
</span><a href="#local-6989586621689361868"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621689361867"><span class="annot"><span class="annottext">Type origin k1
</span><a href="#local-6989586621689361867"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TList"><span class="hs-identifier hs-type">TList</span></a></span><span> </span><span id="local-6989586621689361866"><span class="annot"><span class="annottext">Nullability
</span><a href="#local-6989586621689361866"><span class="hs-identifier hs-var">n'</span></a></span></span><span> </span><span id="local-6989586621689361865"><span class="annot"><span class="annottext">Type origin k2
</span><a href="#local-6989586621689361865"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Nullability
</span><a href="#local-6989586621689361868"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Nullability -&gt; Nullability -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><a href="#local-6989586621689361866"><span class="hs-identifier hs-var">n'</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Type origin k1 -&gt; Type origin k2 -&gt; Bool
forall origin (k1 :: Kind) (k2 :: Kind).
Type origin k1 -&gt; Type origin k2 -&gt; Bool
</span><a href="Hasura.GraphQL.Parser.Schema.html#eqType"><span class="hs-identifier hs-var">eqType</span></a></span><span> </span><span class="annot"><span class="annottext">Type origin k1
</span><a href="#local-6989586621689361867"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">Type origin k2
</span><a href="#local-6989586621689361865"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-312"></span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#eqType"><span class="hs-identifier hs-var">eqType</span></a></span><span> </span><span class="annot"><span class="annottext">Type origin k1
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type origin k2
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-313"></span><span>
</span><span id="line-314"></span><span id="local-6989586621689361863"><span id="local-6989586621689361864"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Names.html#HasName"><span class="hs-identifier hs-type">HasName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361864"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361863"><span class="hs-identifier hs-type">k</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-315"></span><span>  </span><span id="local-6989586621689361860"><span class="annot"><span class="annottext">getName :: Type origin k -&gt; Name
</span><a href="Hasura.GraphQL.Parser.Names.html#getName"><span class="hs-identifier hs-var hs-var hs-var hs-var">getName</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TNamed"><span class="hs-identifier hs-type">TNamed</span></a></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621689361858"><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
</span><a href="#local-6989586621689361858"><span class="hs-identifier hs-var">def</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k) -&gt; Name
forall a. HasName a =&gt; a -&gt; Name
</span><a href="Hasura.GraphQL.Parser.Names.html#getName"><span class="hs-identifier hs-var">getName</span></a></span><span> </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
</span><a href="#local-6989586621689361858"><span class="hs-identifier hs-var">def</span></a></span><span>
</span><span id="line-316"></span><span>  </span><span class="annot"><a href="Hasura.GraphQL.Parser.Names.html#getName"><span class="hs-identifier hs-var">getName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TList"><span class="hs-identifier hs-type">TList</span></a></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621689361857"><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361857"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type origin k -&gt; Name
forall a. HasName a =&gt; a -&gt; Name
</span><a href="Hasura.GraphQL.Parser.Names.html#getName"><span class="hs-identifier hs-var">getName</span></a></span><span> </span><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361857"><span class="hs-identifier hs-var">t</span></a></span></span></span><span>
</span><span id="line-317"></span><span>
</span><span id="line-318"></span><span id="local-6989586621689361855"><span id="local-6989586621689361856"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#typeNullability"><span class="hs-identifier hs-type">typeNullability</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361856"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361855"><span class="hs-identifier hs-type">k</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Nullability"><span class="hs-identifier hs-type">Nullability</span></a></span></span></span><span>
</span><span id="line-319"></span><span id="typeNullability"><span class="annot"><span class="annottext">typeNullability :: Type origin k -&gt; Nullability
</span><a href="Hasura.GraphQL.Parser.Schema.html#typeNullability"><span class="hs-identifier hs-var hs-var">typeNullability</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TNamed"><span class="hs-identifier hs-type">TNamed</span></a></span><span> </span><span id="local-6989586621689361854"><span class="annot"><span class="annottext">Nullability
</span><a href="#local-6989586621689361854"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Nullability
</span><a href="#local-6989586621689361854"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-320"></span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#typeNullability"><span class="hs-identifier hs-var">typeNullability</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TList"><span class="hs-identifier hs-type">TList</span></a></span><span> </span><span id="local-6989586621689361853"><span class="annot"><span class="annottext">Nullability
</span><a href="#local-6989586621689361853"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type origin k
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Nullability
</span><a href="#local-6989586621689361853"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-321"></span><span>
</span><span id="line-322"></span><span id="local-6989586621689361851"><span id="local-6989586621689361852"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#nullableType"><span class="hs-identifier hs-type">nullableType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361852"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361851"><span class="hs-identifier hs-type">k</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361852"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361851"><span class="hs-identifier hs-type">k</span></a></span></span></span><span>
</span><span id="line-323"></span><span id="nullableType"><span class="annot"><span class="annottext">nullableType :: Type origin k -&gt; Type origin k
</span><a href="Hasura.GraphQL.Parser.Schema.html#nullableType"><span class="hs-identifier hs-var hs-var">nullableType</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TNamed"><span class="hs-identifier hs-type">TNamed</span></a></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621689361850"><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
</span><a href="#local-6989586621689361850"><span class="hs-identifier hs-var">def</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Nullability
-&gt; Definition origin (TypeInfo origin k) -&gt; Type origin k
forall origin (k :: Kind).
Nullability
-&gt; Definition origin (TypeInfo origin k) -&gt; Type origin k
</span><a href="Hasura.GraphQL.Parser.Schema.html#TNamed"><span class="hs-identifier hs-var">TNamed</span></a></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><a href="Hasura.GraphQL.Parser.Schema.html#Nullable"><span class="hs-identifier hs-var">Nullable</span></a></span><span> </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
</span><a href="#local-6989586621689361850"><span class="hs-identifier hs-var">def</span></a></span><span>
</span><span id="line-324"></span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#nullableType"><span class="hs-identifier hs-var">nullableType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TList"><span class="hs-identifier hs-type">TList</span></a></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621689361849"><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361849"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Nullability -&gt; Type origin k -&gt; Type origin k
forall origin (k :: Kind).
Nullability -&gt; Type origin k -&gt; Type origin k
</span><a href="Hasura.GraphQL.Parser.Schema.html#TList"><span class="hs-identifier hs-var">TList</span></a></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><a href="Hasura.GraphQL.Parser.Schema.html#Nullable"><span class="hs-identifier hs-var">Nullable</span></a></span><span> </span><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361849"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-325"></span><span>
</span><span id="line-326"></span><span id="local-6989586621689361847"><span id="local-6989586621689361848"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#nonNullableType"><span class="hs-identifier hs-type">nonNullableType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361848"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361847"><span class="hs-identifier hs-type">k</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361848"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361847"><span class="hs-identifier hs-type">k</span></a></span></span></span><span>
</span><span id="line-327"></span><span id="nonNullableType"><span class="annot"><span class="annottext">nonNullableType :: Type origin k -&gt; Type origin k
</span><a href="Hasura.GraphQL.Parser.Schema.html#nonNullableType"><span class="hs-identifier hs-var hs-var">nonNullableType</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TNamed"><span class="hs-identifier hs-type">TNamed</span></a></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621689361846"><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
</span><a href="#local-6989586621689361846"><span class="hs-identifier hs-var">def</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Nullability
-&gt; Definition origin (TypeInfo origin k) -&gt; Type origin k
forall origin (k :: Kind).
Nullability
-&gt; Definition origin (TypeInfo origin k) -&gt; Type origin k
</span><a href="Hasura.GraphQL.Parser.Schema.html#TNamed"><span class="hs-identifier hs-var">TNamed</span></a></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><a href="Hasura.GraphQL.Parser.Schema.html#NonNullable"><span class="hs-identifier hs-var">NonNullable</span></a></span><span> </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
</span><a href="#local-6989586621689361846"><span class="hs-identifier hs-var">def</span></a></span><span>
</span><span id="line-328"></span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#nonNullableType"><span class="hs-identifier hs-var">nonNullableType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TList"><span class="hs-identifier hs-type">TList</span></a></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621689361845"><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361845"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Nullability -&gt; Type origin k -&gt; Type origin k
forall origin (k :: Kind).
Nullability -&gt; Type origin k -&gt; Type origin k
</span><a href="Hasura.GraphQL.Parser.Schema.html#TList"><span class="hs-identifier hs-var">TList</span></a></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><a href="Hasura.GraphQL.Parser.Schema.html#NonNullable"><span class="hs-identifier hs-var">NonNullable</span></a></span><span> </span><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361845"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-329"></span><span>
</span><span id="line-330"></span><span id="local-6989586621689362295"><span id="local-6989586621689362296"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#toGraphQLType"><span class="hs-identifier hs-type">toGraphQLType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362296"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362295"><span class="hs-identifier hs-type">k</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">GType</span></span></span></span><span>
</span><span id="line-331"></span><span id="toGraphQLType"><span class="annot"><span class="annottext">toGraphQLType :: Type origin k -&gt; GType
</span><a href="Hasura.GraphQL.Parser.Schema.html#toGraphQLType"><span class="hs-identifier hs-var hs-var">toGraphQLType</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TNamed"><span class="hs-identifier hs-type">TNamed</span></a></span><span> </span><span id="local-6989586621689361844"><span class="annot"><span class="annottext">Nullability
</span><a href="#local-6989586621689361844"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621689361843"><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
</span><a href="#local-6989586621689361843"><span class="hs-identifier hs-var">typeInfo</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Nullability -&gt; Name -&gt; GType
</span><span class="hs-identifier hs-var">TypeNamed</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Nullability
</span><span class="hs-identifier hs-var">G.Nullability</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Nullability -&gt; Bool
</span><a href="Hasura.GraphQL.Parser.Schema.html#isNullable"><span class="hs-identifier hs-var">isNullable</span></a></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><a href="#local-6989586621689361844"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Name -&gt; GType) -&gt; Name -&gt; GType
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k) -&gt; Name
forall a. HasName a =&gt; a -&gt; Name
</span><a href="Hasura.GraphQL.Parser.Names.html#getName"><span class="hs-identifier hs-var">getName</span></a></span><span> </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
</span><a href="#local-6989586621689361843"><span class="hs-identifier hs-var">typeInfo</span></a></span><span>
</span><span id="line-332"></span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#toGraphQLType"><span class="hs-identifier hs-var">toGraphQLType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TList"><span class="hs-identifier hs-type">TList</span></a></span><span> </span><span id="local-6989586621689361840"><span class="annot"><span class="annottext">Nullability
</span><a href="#local-6989586621689361840"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621689361839"><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361839"><span class="hs-identifier hs-var">typeInfo</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Nullability -&gt; GType -&gt; GType
</span><span class="hs-identifier hs-var">TypeList</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Nullability
</span><span class="hs-identifier hs-var">G.Nullability</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Nullability -&gt; Bool
</span><a href="Hasura.GraphQL.Parser.Schema.html#isNullable"><span class="hs-identifier hs-var">isNullable</span></a></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><a href="#local-6989586621689361840"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(GType -&gt; GType) -&gt; GType -&gt; GType
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type origin k -&gt; GType
forall origin (k :: Kind). Type origin k -&gt; GType
</span><a href="Hasura.GraphQL.Parser.Schema.html#toGraphQLType"><span class="hs-identifier hs-var">toGraphQLType</span></a></span><span> </span><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361839"><span class="hs-identifier hs-var">typeInfo</span></a></span><span>
</span><span id="line-333"></span><span>
</span><span id="line-334"></span><span class="hs-comment">{- Note [The interfaces story]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
GraphQL interfaces are not conceptually complicated, but they pose some
non-obvious challenges for our implementation. First, familiarize yourself with
GraphQL interfaces themselves:

  * https://graphql.org/learn/schema/#interfaces
  * http://spec.graphql.org/June2018/#sec-Interfaces
  * http://spec.graphql.org/June2018/#sec-Objects

The most logical repesentation of object and interface types is to have objects
reference the interfaces they implement, but not the other way around. After
all, that&#8217;s how it works in the GraphQL language: when you declare an interface,
you just specify its fields, and you specify which interfaces each object type
implements as part of their declarations.

However, this representation is actually not very useful for us. We /also/ need
the interfaces to reference the objects that implement them---forming a circular
structure---for two reasons:

  1. Most directly, we need this information for introspection queries.
     Introspection queries for object types return the set of interfaces they
     implement &lt;http://spec.graphql.org/June2018/#sec-Object&gt;, and introspection
     queries for interfaces return the set of object types that implement them
     &lt;http://spec.graphql.org/June2018/#sec-Interface&gt;.

  2. Less obviously, it&#8217;s more natural to specify the relationships &#8220;backwards&#8221;
     like this when building the schema using the parser combinator language.

     From the parser&#8217;s point of view, each implementation of an interface
     corresponds to a distinct parsing possibility. For example, when we
     generate a Relay schema, the type of the `node` root field is an interface,
     and each table is a type that implements it:

         type query_root {
           node(id: ID!): Node
           ...
         }

         interface Node {
           id: ID!
         }

         type author implements Node {
           id: ID!
           name: String!
           ...
         }

         type article implements Node {
           id: ID!
           title: String!
           body: String!
           ...
         }

     A query will use fragments on the Node type to access table-specific fields:

         query get_article_info($article_id: ID!) {
           node(id: $article_id) {
             ... on article {
               title
               body
             }
           }
         }

     The query parser needs to know which types implement the interface (and
     how to parse their selection sets) so that it can parse the fragments.

This presents some complications, since we need to build this information in a
circular fashion. Currently, we do this in a very na&#239;ve way:

  * We require selectionSetObject to specify the interfaces it implements /and/
    require selectionSetInterface to specify the objects that implement it.

  * We take advantage of our existing memoization mechanism to do the knot-tying
    for us (see Note [Tying the knot] in Hasura.GraphQL.Parser.Class).

You may notice that this makes it possible for the definitions to be
inconsistent: we could construct an interface parser that parses some object
type, but forget to specify that the object type implements the interface. This
inconsistency is currently completely unchecked, which is quite unfortunate. It
also means we don&#8217;t support remote schema-defined object types that implement
interfaces we generate, since we don&#8217;t know anything about those types when we
construct the interface.

Since we don&#8217;t make very much use of interface types at the time of this
writing, this isn&#8217;t much of a problem in practice. But if that changes, it would
be worth implementing a more sophisticated solution that can gather up all the
different sources of information and make sure they&#8217;re consistent. -}</span><span>
</span><span id="line-425"></span><span>
</span><span id="line-426"></span><span class="hs-comment">-- | Invariant: the list is sorted by 'dName'</span><span>
</span><span id="line-427"></span><span class="hs-keyword">data</span><span> </span><span id="InputObjectInfo"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputObjectInfo"><span class="hs-identifier hs-var">InputObjectInfo</span></a></span></span><span> </span><span id="local-6989586621689362288"><span class="annot"><a href="#local-6989586621689362288"><span class="hs-identifier hs-type">origin</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="InputObjectInfo__"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputObjectInfo__"><span class="hs-identifier hs-var">InputObjectInfo__</span></a></span></span><span> </span><span class="hs-glyph">~</span><span class="hs-special">[</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362288"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputFieldInfo"><span class="hs-identifier hs-type">InputFieldInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362288"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-428"></span><span>
</span><span id="line-429"></span><span class="hs-comment">-- Public interface enforcing invariants</span><span>
</span><span id="line-430"></span><span id="local-6989586621689362293"><span class="hs-keyword">pattern</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputObjectInfo"><span class="hs-identifier hs-type">InputObjectInfo</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362293"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputFieldInfo"><span class="hs-identifier hs-type">InputFieldInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362293"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputObjectInfo"><span class="hs-identifier hs-type">InputObjectInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362293"><span class="hs-identifier hs-type">origin</span></a></span></span><span>
</span><span id="line-431"></span><span class="hs-keyword">pattern</span><span> </span><span id="%24bInputObjectInfo"><span id="%24mInputObjectInfo"><span id="InputObjectInfo"><span class="annot"><span class="annottext">$bInputObjectInfo :: [Definition origin (InputFieldInfo origin)]
-&gt; InputObjectInfo origin
$mInputObjectInfo :: forall r origin.
InputObjectInfo origin
-&gt; ([Definition origin (InputFieldInfo origin)] -&gt; r)
-&gt; (Void# -&gt; r)
-&gt; r
</span><a href="Hasura.GraphQL.Parser.Schema.html#%24bInputObjectInfo"><span class="hs-identifier hs-var hs-var hs-var hs-var">InputObjectInfo</span></a></span></span></span></span><span> </span><span class="annot"><a href="#local-6989586621689361834"><span class="hs-identifier hs-type">xs</span></a></span><span> </span><span class="hs-glyph">&lt;-</span><span>
</span><span id="line-432"></span><span>  </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputObjectInfo__"><span class="hs-identifier hs-type">InputObjectInfo__</span></a></span><span> </span><span id="local-6989586621689361834"><span class="annot"><a href="#local-6989586621689361834"><span class="hs-identifier hs-var">xs</span></a></span></span><span>
</span><span id="line-433"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-434"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputObjectInfo"><span class="hs-identifier hs-var">InputObjectInfo</span></a></span><span> </span><span id="local-6989586621689361833"><span class="annot"><span class="annottext">[Definition origin (InputFieldInfo origin)]
</span><a href="#local-6989586621689361833"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Definition origin (InputFieldInfo origin)]
-&gt; InputObjectInfo origin
forall origin.
[Definition origin (InputFieldInfo origin)]
-&gt; InputObjectInfo origin
</span><a href="Hasura.GraphQL.Parser.Schema.html#InputObjectInfo__"><span class="hs-identifier hs-var">InputObjectInfo__</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Definition origin (InputFieldInfo origin) -&gt; Name)
-&gt; [Definition origin (InputFieldInfo origin)]
-&gt; [Definition origin (InputFieldInfo origin)]
forall b a. Ord b =&gt; (a -&gt; b) -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">List.sortOn</span></span><span> </span><span class="annot"><span class="annottext">Definition origin (InputFieldInfo origin) -&gt; Name
forall origin a. Definition origin a -&gt; Name
</span><a href="Hasura.GraphQL.Parser.Schema.html#dName"><span class="hs-identifier hs-var hs-var">dName</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (InputFieldInfo origin)]
</span><a href="#local-6989586621689361833"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-435"></span><span>
</span><span id="line-436"></span><span class="hs-pragma">{-# COMPLETE</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputObjectInfo"><span class="hs-pragma hs-type">InputObjectInfo</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-437"></span><span>
</span><span id="line-438"></span><span class="hs-comment">-- Note that we can't check for equality of the fields since there may be</span><span>
</span><span id="line-439"></span><span class="hs-comment">-- circularity. So we rather check for equality of names.</span><span>
</span><span id="line-440"></span><span id="local-6989586621689361830"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621689361827"><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputObjectInfo"><span class="hs-identifier hs-type">InputObjectInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361830"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-441"></span><span>  </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputObjectInfo"><span class="hs-identifier hs-type">InputObjectInfo</span></a></span><span> </span><span id="local-6989586621689361826"><span class="annot"><span class="annottext">[Definition origin (InputFieldInfo origin)]
</span><a href="#local-6989586621689361826"><span class="hs-identifier hs-var">fields1</span></a></span></span><span> </span><span id="local-6989586621689361825"><span class="annot"><span class="annottext">== :: InputObjectInfo origin -&gt; InputObjectInfo origin -&gt; Bool
</span><span class="hs-operator hs-var hs-var hs-var hs-var">==</span></span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputObjectInfo"><span class="hs-identifier hs-type">InputObjectInfo</span></a></span><span> </span><span id="local-6989586621689361824"><span class="annot"><span class="annottext">[Definition origin (InputFieldInfo origin)]
</span><a href="#local-6989586621689361824"><span class="hs-identifier hs-var">fields2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-442"></span><span>    </span><span class="annot"><span class="annottext">[Definition origin (InputFieldInfo origin)]
-&gt; [Definition origin (InputFieldInfo origin)] -&gt; Bool
forall origin a.
[Definition origin a] -&gt; [Definition origin a] -&gt; Bool
</span><a href="Hasura.GraphQL.Parser.Schema.html#eqByName"><span class="hs-identifier hs-var">eqByName</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (InputFieldInfo origin)]
</span><a href="#local-6989586621689361826"><span class="hs-identifier hs-var">fields1</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (InputFieldInfo origin)]
</span><a href="#local-6989586621689361824"><span class="hs-identifier hs-var">fields2</span></a></span></span><span>
</span><span id="line-443"></span><span>
</span><span id="line-444"></span><span class="hs-comment">-- | Invariant: the lists are sorted by 'dName', maintained via pattern synonyms</span><span>
</span><span id="line-445"></span><span class="hs-keyword">data</span><span> </span><span id="ObjectInfo"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ObjectInfo"><span class="hs-identifier hs-var">ObjectInfo</span></a></span></span><span> </span><span id="local-6989586621689362269"><span class="annot"><a href="#local-6989586621689362269"><span class="hs-identifier hs-type">origin</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="ObjectInfo__"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ObjectInfo__"><span class="hs-identifier hs-var">ObjectInfo__</span></a></span></span><span>
</span><span id="line-446"></span><span>  </span><span class="hs-special">{</span><span> </span><span class="hs-comment">-- | The fields that this object has.  This consists of the fields of the</span><span>
</span><span id="line-447"></span><span>    </span><span class="hs-comment">-- interfaces that it implements, as well as any additional fields.</span><span>
</span><span id="line-448"></span><span>    </span><span id="_oiFields"><span class="annot"><span class="annottext">ObjectInfo origin -&gt; [Definition origin (FieldInfo origin)]
</span><a href="Hasura.GraphQL.Parser.Schema.html#_oiFields"><span class="hs-identifier hs-var hs-var">_oiFields</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">~</span><span class="hs-special">[</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362269"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#FieldInfo"><span class="hs-identifier hs-type">FieldInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362269"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-449"></span><span>    </span><span class="hs-comment">-- | The interfaces that this object implements (inheriting all their</span><span>
</span><span id="line-450"></span><span>    </span><span class="hs-comment">-- fields). See Note [The interfaces story] for more details.</span><span>
</span><span id="line-451"></span><span>    </span><span id="_oiImplements"><span class="annot"><span class="annottext">ObjectInfo origin -&gt; [Definition origin (InterfaceInfo origin)]
</span><a href="Hasura.GraphQL.Parser.Schema.html#_oiImplements"><span class="hs-identifier hs-var hs-var">_oiImplements</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">~</span><span class="hs-special">[</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362269"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InterfaceInfo"><span class="hs-identifier hs-type">InterfaceInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362269"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-452"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-453"></span><span>
</span><span id="line-454"></span><span class="hs-comment">-- Public interface enforcing invariants</span><span>
</span><span id="line-455"></span><span id="local-6989586621689362274"><span class="hs-keyword">pattern</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ObjectInfo"><span class="hs-identifier hs-type">ObjectInfo</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362274"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#FieldInfo"><span class="hs-identifier hs-type">FieldInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362274"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362274"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InterfaceInfo"><span class="hs-identifier hs-type">InterfaceInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362274"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ObjectInfo"><span class="hs-identifier hs-type">ObjectInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362274"><span class="hs-identifier hs-type">origin</span></a></span></span><span>
</span><span id="line-456"></span><span class="hs-keyword">pattern</span><span> </span><span id="%24bObjectInfo"><span id="%24mObjectInfo"><span id="ObjectInfo"><span class="annot"><span class="annottext">$bObjectInfo :: [Definition origin (FieldInfo origin)]
-&gt; [Definition origin (InterfaceInfo origin)] -&gt; ObjectInfo origin
$mObjectInfo :: forall r origin.
ObjectInfo origin
-&gt; ([Definition origin (FieldInfo origin)]
    -&gt; [Definition origin (InterfaceInfo origin)] -&gt; r)
-&gt; (Void# -&gt; r)
-&gt; r
</span><a href="Hasura.GraphQL.Parser.Schema.html#%24bObjectInfo"><span class="hs-identifier hs-var hs-var hs-var hs-var">ObjectInfo</span></a></span></span></span></span><span> </span><span class="hs-special">{</span><span id="oiFields"><span class="annot"><span class="annottext">ObjectInfo origin -&gt; [Definition origin (FieldInfo origin)]
</span><a href="#local-6989586621689361817"><span class="hs-identifier hs-var hs-var hs-var">oiFields</span></a></span></span><span class="hs-special">,</span><span> </span><span id="oiImplements"><span class="annot"><span class="annottext">ObjectInfo origin -&gt; [Definition origin (InterfaceInfo origin)]
</span><a href="#local-6989586621689361816"><span class="hs-identifier hs-var hs-var hs-var">oiImplements</span></a></span></span><span class="hs-special">}</span><span> </span><span class="hs-glyph">&lt;-</span><span>
</span><span id="line-457"></span><span>  </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ObjectInfo__"><span class="hs-identifier hs-type">ObjectInfo__</span></a></span><span> </span><span id="local-6989586621689361817"><span class="annot"><a href="#local-6989586621689361817"><span class="hs-identifier hs-var">oiFields</span></a></span></span><span> </span><span id="local-6989586621689361816"><span class="annot"><a href="#local-6989586621689361816"><span class="hs-identifier hs-var">oiImplements</span></a></span></span><span>
</span><span id="line-458"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-459"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ObjectInfo"><span class="hs-identifier hs-var">ObjectInfo</span></a></span><span> </span><span id="local-6989586621689361815"><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
</span><a href="#local-6989586621689361815"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span id="local-6989586621689361814"><span class="annot"><span class="annottext">[Definition origin (InterfaceInfo origin)]
</span><a href="#local-6989586621689361814"><span class="hs-identifier hs-var">ys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
-&gt; [Definition origin (InterfaceInfo origin)] -&gt; ObjectInfo origin
forall origin.
[Definition origin (FieldInfo origin)]
-&gt; [Definition origin (InterfaceInfo origin)] -&gt; ObjectInfo origin
</span><a href="Hasura.GraphQL.Parser.Schema.html#ObjectInfo__"><span class="hs-identifier hs-var">ObjectInfo__</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Definition origin (FieldInfo origin) -&gt; Name)
-&gt; [Definition origin (FieldInfo origin)]
-&gt; [Definition origin (FieldInfo origin)]
forall b a. Ord b =&gt; (a -&gt; b) -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">List.sortOn</span></span><span> </span><span class="annot"><span class="annottext">Definition origin (FieldInfo origin) -&gt; Name
forall origin a. Definition origin a -&gt; Name
</span><a href="Hasura.GraphQL.Parser.Schema.html#dName"><span class="hs-identifier hs-var hs-var">dName</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
</span><a href="#local-6989586621689361815"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Definition origin (InterfaceInfo origin) -&gt; Name)
-&gt; [Definition origin (InterfaceInfo origin)]
-&gt; [Definition origin (InterfaceInfo origin)]
forall b a. Ord b =&gt; (a -&gt; b) -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">List.sortOn</span></span><span> </span><span class="annot"><span class="annottext">Definition origin (InterfaceInfo origin) -&gt; Name
forall origin a. Definition origin a -&gt; Name
</span><a href="Hasura.GraphQL.Parser.Schema.html#dName"><span class="hs-identifier hs-var hs-var">dName</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (InterfaceInfo origin)]
</span><a href="#local-6989586621689361814"><span class="hs-identifier hs-var">ys</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-460"></span><span>
</span><span id="line-461"></span><span class="hs-pragma">{-# COMPLETE</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ObjectInfo"><span class="hs-pragma hs-type">ObjectInfo</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-462"></span><span>
</span><span id="line-463"></span><span class="hs-comment">-- | Note that we can't check for equality of the fields and the interfaces since</span><span>
</span><span id="line-464"></span><span class="hs-comment">-- there may be circularity. So we rather check for equality of names.</span><span>
</span><span id="line-465"></span><span class="hs-comment">--</span><span>
</span><span id="line-466"></span><span class="hs-comment">-- This is dodgy... the equality logic here should I think correspond to the</span><span>
</span><span id="line-467"></span><span class="hs-comment">-- logic in @typeField@ and its neighbors in &quot;Hasura.GraphQL.Schema.Introspect&quot;,</span><span>
</span><span id="line-468"></span><span class="hs-comment">-- in terms of how much we recurse.</span><span>
</span><span id="line-469"></span><span id="local-6989586621689361813"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621689361810"><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ObjectInfo"><span class="hs-identifier hs-type">ObjectInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361813"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-470"></span><span>  </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ObjectInfo"><span class="hs-identifier hs-type">ObjectInfo</span></a></span><span> </span><span id="local-6989586621689361809"><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
</span><a href="#local-6989586621689361809"><span class="hs-identifier hs-var">fields1</span></a></span></span><span> </span><span id="local-6989586621689361808"><span class="annot"><span class="annottext">[Definition origin (InterfaceInfo origin)]
</span><a href="#local-6989586621689361808"><span class="hs-identifier hs-var">interfaces1</span></a></span></span><span> </span><span id="local-6989586621689361807"><span class="annot"><span class="annottext">== :: ObjectInfo origin -&gt; ObjectInfo origin -&gt; Bool
</span><span class="hs-operator hs-var hs-var hs-var hs-var">==</span></span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ObjectInfo"><span class="hs-identifier hs-type">ObjectInfo</span></a></span><span> </span><span id="local-6989586621689361806"><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
</span><a href="#local-6989586621689361806"><span class="hs-identifier hs-var">fields2</span></a></span></span><span> </span><span id="local-6989586621689361805"><span class="annot"><span class="annottext">[Definition origin (InterfaceInfo origin)]
</span><a href="#local-6989586621689361805"><span class="hs-identifier hs-var">interfaces2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-471"></span><span>    </span><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
-&gt; [Definition origin (FieldInfo origin)] -&gt; Bool
forall origin a.
[Definition origin a] -&gt; [Definition origin a] -&gt; Bool
</span><a href="Hasura.GraphQL.Parser.Schema.html#eqByName"><span class="hs-identifier hs-var">eqByName</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
</span><a href="#local-6989586621689361809"><span class="hs-identifier hs-var">fields1</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
</span><a href="#local-6989586621689361806"><span class="hs-identifier hs-var">fields2</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">[Definition origin (InterfaceInfo origin)]
-&gt; [Definition origin (InterfaceInfo origin)] -&gt; Bool
forall origin a.
[Definition origin a] -&gt; [Definition origin a] -&gt; Bool
</span><a href="Hasura.GraphQL.Parser.Schema.html#eqByName"><span class="hs-identifier hs-var">eqByName</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (InterfaceInfo origin)]
</span><a href="#local-6989586621689361808"><span class="hs-identifier hs-var">interfaces1</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (InterfaceInfo origin)]
</span><a href="#local-6989586621689361805"><span class="hs-identifier hs-var">interfaces2</span></a></span></span><span>
</span><span id="line-472"></span><span>
</span><span id="line-473"></span><span class="hs-comment">-- | Type information for a GraphQL interface; see Note [The interfaces story]</span><span>
</span><span id="line-474"></span><span class="hs-comment">-- for more details.</span><span>
</span><span id="line-475"></span><span class="hs-comment">--</span><span>
</span><span id="line-476"></span><span class="hs-comment">-- Note: in the current working draft of the GraphQL specification (&gt; June</span><span>
</span><span id="line-477"></span><span class="hs-comment">-- 2018), interfaces may implement other interfaces, but we currently don't</span><span>
</span><span id="line-478"></span><span class="hs-comment">-- support this.</span><span>
</span><span id="line-479"></span><span class="hs-comment">--</span><span>
</span><span id="line-480"></span><span class="hs-comment">-- Invariant: the lists are sorted by 'dName', maintained via pattern synonyms</span><span>
</span><span id="line-481"></span><span class="hs-keyword">data</span><span> </span><span id="InterfaceInfo"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InterfaceInfo"><span class="hs-identifier hs-var">InterfaceInfo</span></a></span></span><span> </span><span id="local-6989586621689362259"><span class="annot"><a href="#local-6989586621689362259"><span class="hs-identifier hs-type">origin</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="InterfaceInfo__"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InterfaceInfo__"><span class="hs-identifier hs-var">InterfaceInfo__</span></a></span></span><span>
</span><span id="line-482"></span><span>  </span><span class="hs-special">{</span><span> </span><span class="hs-comment">-- | Fields declared by this interface. Every object implementing this</span><span>
</span><span id="line-483"></span><span>    </span><span class="hs-comment">-- interface must include those fields.</span><span>
</span><span id="line-484"></span><span>    </span><span id="_iiFields"><span class="annot"><span class="annottext">InterfaceInfo origin -&gt; [Definition origin (FieldInfo origin)]
</span><a href="Hasura.GraphQL.Parser.Schema.html#_iiFields"><span class="hs-identifier hs-var hs-var">_iiFields</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">~</span><span class="hs-special">[</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362259"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#FieldInfo"><span class="hs-identifier hs-type">FieldInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362259"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-485"></span><span>    </span><span class="hs-comment">-- | Objects that implement this interface. See Note [The interfaces story]</span><span>
</span><span id="line-486"></span><span>    </span><span class="hs-comment">-- for why we include that information here.</span><span>
</span><span id="line-487"></span><span>    </span><span id="_iiPossibleTypes"><span class="annot"><span class="annottext">InterfaceInfo origin -&gt; [Definition origin (ObjectInfo origin)]
</span><a href="Hasura.GraphQL.Parser.Schema.html#_iiPossibleTypes"><span class="hs-identifier hs-var hs-var">_iiPossibleTypes</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">~</span><span class="hs-special">[</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362259"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ObjectInfo"><span class="hs-identifier hs-type">ObjectInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362259"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-488"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-489"></span><span>
</span><span id="line-490"></span><span class="hs-comment">-- Public interface enforcing invariants</span><span>
</span><span id="line-491"></span><span id="local-6989586621689362264"><span class="hs-keyword">pattern</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InterfaceInfo"><span class="hs-identifier hs-type">InterfaceInfo</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362264"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#FieldInfo"><span class="hs-identifier hs-type">FieldInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362264"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362264"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ObjectInfo"><span class="hs-identifier hs-type">ObjectInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362264"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InterfaceInfo"><span class="hs-identifier hs-type">InterfaceInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362264"><span class="hs-identifier hs-type">origin</span></a></span></span><span>
</span><span id="line-492"></span><span class="hs-keyword">pattern</span><span> </span><span id="%24bInterfaceInfo"><span id="%24mInterfaceInfo"><span id="InterfaceInfo"><span class="annot"><span class="annottext">$bInterfaceInfo :: [Definition origin (FieldInfo origin)]
-&gt; [Definition origin (ObjectInfo origin)] -&gt; InterfaceInfo origin
$mInterfaceInfo :: forall r origin.
InterfaceInfo origin
-&gt; ([Definition origin (FieldInfo origin)]
    -&gt; [Definition origin (ObjectInfo origin)] -&gt; r)
-&gt; (Void# -&gt; r)
-&gt; r
</span><a href="Hasura.GraphQL.Parser.Schema.html#%24bInterfaceInfo"><span class="hs-identifier hs-var hs-var hs-var hs-var">InterfaceInfo</span></a></span></span></span></span><span> </span><span class="hs-special">{</span><span id="iiFields"><span class="annot"><span class="annottext">InterfaceInfo origin -&gt; [Definition origin (FieldInfo origin)]
</span><a href="#local-6989586621689361799"><span class="hs-identifier hs-var hs-var hs-var">iiFields</span></a></span></span><span class="hs-special">,</span><span> </span><span id="iiPossibleTypes"><span class="annot"><span class="annottext">InterfaceInfo origin -&gt; [Definition origin (ObjectInfo origin)]
</span><a href="#local-6989586621689361798"><span class="hs-identifier hs-var hs-var hs-var">iiPossibleTypes</span></a></span></span><span class="hs-special">}</span><span> </span><span class="hs-glyph">&lt;-</span><span>
</span><span id="line-493"></span><span>  </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InterfaceInfo__"><span class="hs-identifier hs-type">InterfaceInfo__</span></a></span><span> </span><span id="local-6989586621689361799"><span class="annot"><a href="#local-6989586621689361799"><span class="hs-identifier hs-var">iiFields</span></a></span></span><span> </span><span id="local-6989586621689361798"><span class="annot"><a href="#local-6989586621689361798"><span class="hs-identifier hs-var">iiPossibleTypes</span></a></span></span><span>
</span><span id="line-494"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-495"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InterfaceInfo"><span class="hs-identifier hs-var">InterfaceInfo</span></a></span><span> </span><span id="local-6989586621689361797"><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
</span><a href="#local-6989586621689361797"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span id="local-6989586621689361796"><span class="annot"><span class="annottext">[Definition origin (ObjectInfo origin)]
</span><a href="#local-6989586621689361796"><span class="hs-identifier hs-var">ys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
-&gt; [Definition origin (ObjectInfo origin)] -&gt; InterfaceInfo origin
forall origin.
[Definition origin (FieldInfo origin)]
-&gt; [Definition origin (ObjectInfo origin)] -&gt; InterfaceInfo origin
</span><a href="Hasura.GraphQL.Parser.Schema.html#InterfaceInfo__"><span class="hs-identifier hs-var">InterfaceInfo__</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Definition origin (FieldInfo origin) -&gt; Name)
-&gt; [Definition origin (FieldInfo origin)]
-&gt; [Definition origin (FieldInfo origin)]
forall b a. Ord b =&gt; (a -&gt; b) -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">List.sortOn</span></span><span> </span><span class="annot"><span class="annottext">Definition origin (FieldInfo origin) -&gt; Name
forall origin a. Definition origin a -&gt; Name
</span><a href="Hasura.GraphQL.Parser.Schema.html#dName"><span class="hs-identifier hs-var hs-var">dName</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
</span><a href="#local-6989586621689361797"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Definition origin (ObjectInfo origin) -&gt; Name)
-&gt; [Definition origin (ObjectInfo origin)]
-&gt; [Definition origin (ObjectInfo origin)]
forall b a. Ord b =&gt; (a -&gt; b) -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">List.sortOn</span></span><span> </span><span class="annot"><span class="annottext">Definition origin (ObjectInfo origin) -&gt; Name
forall origin a. Definition origin a -&gt; Name
</span><a href="Hasura.GraphQL.Parser.Schema.html#dName"><span class="hs-identifier hs-var hs-var">dName</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (ObjectInfo origin)]
</span><a href="#local-6989586621689361796"><span class="hs-identifier hs-var">ys</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-496"></span><span>
</span><span id="line-497"></span><span class="hs-pragma">{-# COMPLETE</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InterfaceInfo"><span class="hs-pragma hs-type">InterfaceInfo</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-498"></span><span>
</span><span id="line-499"></span><span class="hs-comment">-- Note that we can't check for equality of the fields and the interfaces since</span><span>
</span><span id="line-500"></span><span class="hs-comment">-- there may be circularity. So we rather check for equality of names.</span><span>
</span><span id="line-501"></span><span id="local-6989586621689361795"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621689361792"><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InterfaceInfo"><span class="hs-identifier hs-type">InterfaceInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361795"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-502"></span><span>  </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InterfaceInfo"><span class="hs-identifier hs-type">InterfaceInfo</span></a></span><span> </span><span id="local-6989586621689361791"><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
</span><a href="#local-6989586621689361791"><span class="hs-identifier hs-var">fields1</span></a></span></span><span> </span><span id="local-6989586621689361790"><span class="annot"><span class="annottext">[Definition origin (ObjectInfo origin)]
</span><a href="#local-6989586621689361790"><span class="hs-identifier hs-var">objects1</span></a></span></span><span> </span><span id="local-6989586621689361789"><span class="annot"><span class="annottext">== :: InterfaceInfo origin -&gt; InterfaceInfo origin -&gt; Bool
</span><span class="hs-operator hs-var hs-var hs-var hs-var">==</span></span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InterfaceInfo"><span class="hs-identifier hs-type">InterfaceInfo</span></a></span><span> </span><span id="local-6989586621689361788"><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
</span><a href="#local-6989586621689361788"><span class="hs-identifier hs-var">fields2</span></a></span></span><span> </span><span id="local-6989586621689361787"><span class="annot"><span class="annottext">[Definition origin (ObjectInfo origin)]
</span><a href="#local-6989586621689361787"><span class="hs-identifier hs-var">objects2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-503"></span><span>    </span><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
-&gt; [Definition origin (FieldInfo origin)] -&gt; Bool
forall origin a.
[Definition origin a] -&gt; [Definition origin a] -&gt; Bool
</span><a href="Hasura.GraphQL.Parser.Schema.html#eqByName"><span class="hs-identifier hs-var">eqByName</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
</span><a href="#local-6989586621689361791"><span class="hs-identifier hs-var">fields1</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
</span><a href="#local-6989586621689361788"><span class="hs-identifier hs-var">fields2</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">[Definition origin (ObjectInfo origin)]
-&gt; [Definition origin (ObjectInfo origin)] -&gt; Bool
forall origin a.
[Definition origin a] -&gt; [Definition origin a] -&gt; Bool
</span><a href="Hasura.GraphQL.Parser.Schema.html#eqByName"><span class="hs-identifier hs-var">eqByName</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (ObjectInfo origin)]
</span><a href="#local-6989586621689361790"><span class="hs-identifier hs-var">objects1</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (ObjectInfo origin)]
</span><a href="#local-6989586621689361787"><span class="hs-identifier hs-var">objects2</span></a></span></span><span>
</span><span id="line-504"></span><span>
</span><span id="line-505"></span><span class="hs-comment">-- | Invariant: the list is sorted by 'dName'</span><span>
</span><span id="line-506"></span><span class="hs-keyword">data</span><span> </span><span id="UnionInfo"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#UnionInfo"><span class="hs-identifier hs-var">UnionInfo</span></a></span></span><span> </span><span id="local-6989586621689362250"><span class="annot"><a href="#local-6989586621689362250"><span class="hs-identifier hs-type">origin</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="UnionInfo__"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#UnionInfo__"><span class="hs-identifier hs-var">UnionInfo__</span></a></span></span><span>
</span><span id="line-507"></span><span>  </span><span class="hs-special">{</span><span> </span><span class="hs-comment">-- | The member object types of this union.</span><span>
</span><span id="line-508"></span><span>    </span><span id="_uiPossibleTypes"><span class="annot"><span class="annottext">UnionInfo origin -&gt; [Definition origin (ObjectInfo origin)]
</span><a href="Hasura.GraphQL.Parser.Schema.html#_uiPossibleTypes"><span class="hs-identifier hs-var hs-var">_uiPossibleTypes</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">~</span><span class="hs-special">[</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362250"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ObjectInfo"><span class="hs-identifier hs-type">ObjectInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362250"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-509"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-510"></span><span>
</span><span id="line-511"></span><span class="hs-comment">-- Public interface enforcing invariants</span><span>
</span><span id="line-512"></span><span id="local-6989586621689362254"><span class="hs-keyword">pattern</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#UnionInfo"><span class="hs-identifier hs-type">UnionInfo</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362254"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ObjectInfo"><span class="hs-identifier hs-type">ObjectInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362254"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#UnionInfo"><span class="hs-identifier hs-type">UnionInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362254"><span class="hs-identifier hs-type">origin</span></a></span></span><span>
</span><span id="line-513"></span><span class="hs-keyword">pattern</span><span> </span><span id="%24bUnionInfo"><span id="%24mUnionInfo"><span id="UnionInfo"><span class="annot"><span class="annottext">$bUnionInfo :: [Definition origin (ObjectInfo origin)] -&gt; UnionInfo origin
$mUnionInfo :: forall r origin.
UnionInfo origin
-&gt; ([Definition origin (ObjectInfo origin)] -&gt; r)
-&gt; (Void# -&gt; r)
-&gt; r
</span><a href="Hasura.GraphQL.Parser.Schema.html#%24bUnionInfo"><span class="hs-identifier hs-var hs-var hs-var hs-var">UnionInfo</span></a></span></span></span></span><span> </span><span class="hs-special">{</span><span id="uiPossibleTypes"><span class="annot"><span class="annottext">UnionInfo origin -&gt; [Definition origin (ObjectInfo origin)]
</span><a href="#local-6989586621689361782"><span class="hs-identifier hs-var hs-var hs-var">uiPossibleTypes</span></a></span></span><span class="hs-special">}</span><span> </span><span class="hs-glyph">&lt;-</span><span>
</span><span id="line-514"></span><span>  </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#UnionInfo__"><span class="hs-identifier hs-type">UnionInfo__</span></a></span><span> </span><span id="local-6989586621689361782"><span class="annot"><a href="#local-6989586621689361782"><span class="hs-identifier hs-var">uiPossibleTypes</span></a></span></span><span>
</span><span id="line-515"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-516"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#UnionInfo"><span class="hs-identifier hs-var">UnionInfo</span></a></span><span> </span><span id="local-6989586621689361781"><span class="annot"><span class="annottext">[Definition origin (ObjectInfo origin)]
</span><a href="#local-6989586621689361781"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Definition origin (ObjectInfo origin)] -&gt; UnionInfo origin
forall origin.
[Definition origin (ObjectInfo origin)] -&gt; UnionInfo origin
</span><a href="Hasura.GraphQL.Parser.Schema.html#UnionInfo__"><span class="hs-identifier hs-var">UnionInfo__</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Definition origin (ObjectInfo origin) -&gt; Name)
-&gt; [Definition origin (ObjectInfo origin)]
-&gt; [Definition origin (ObjectInfo origin)]
forall b a. Ord b =&gt; (a -&gt; b) -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">List.sortOn</span></span><span> </span><span class="annot"><span class="annottext">Definition origin (ObjectInfo origin) -&gt; Name
forall origin a. Definition origin a -&gt; Name
</span><a href="Hasura.GraphQL.Parser.Schema.html#dName"><span class="hs-identifier hs-var hs-var">dName</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (ObjectInfo origin)]
</span><a href="#local-6989586621689361781"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-517"></span><span>
</span><span id="line-518"></span><span class="hs-pragma">{-# COMPLETE</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#UnionInfo"><span class="hs-pragma hs-type">UnionInfo</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-519"></span><span>
</span><span id="line-520"></span><span class="hs-keyword">data</span><span> </span><span id="TypeInfo"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeInfo"><span class="hs-identifier hs-var">TypeInfo</span></a></span></span><span> </span><span id="local-6989586621689361780"><span class="annot"><a href="#local-6989586621689361780"><span class="hs-identifier hs-type">origin</span></a></span></span><span> </span><span id="local-6989586621689361779"><span class="annot"><a href="#local-6989586621689361779"><span class="hs-identifier hs-type">k</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-521"></span><span>  </span><span id="local-6989586621689361778"><span id="TIScalar"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIScalar"><span class="hs-identifier hs-var">TIScalar</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeInfo"><span class="hs-identifier hs-type">TypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361778"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">'</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Both"><span class="hs-identifier hs-type">Both</span></a></span></span><span>
</span><span id="line-522"></span><span>  </span><span class="hs-comment">-- | Invariant: the NonEmpty is sorted by 'dName'</span><span>
</span><span id="line-523"></span><span>  </span><span id="local-6989586621689362241"><span id="TIEnum__"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIEnum__"><span class="hs-identifier hs-var">TIEnum__</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NonEmpty</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362241"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#EnumValueInfo"><span class="hs-identifier hs-type">EnumValueInfo</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeInfo"><span class="hs-identifier hs-type">TypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362241"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">'</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Both"><span class="hs-identifier hs-type">Both</span></a></span></span><span>
</span><span id="line-524"></span><span>  </span><span id="local-6989586621689361954"><span id="TIInputObject"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIInputObject"><span class="hs-identifier hs-var">TIInputObject</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputObjectInfo"><span class="hs-identifier hs-type">InputObjectInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361954"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeInfo"><span class="hs-identifier hs-type">TypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361954"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">'</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Input"><span class="hs-identifier hs-type">Input</span></a></span></span><span>
</span><span id="line-525"></span><span>  </span><span id="local-6989586621689361946"><span id="TIObject"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIObject"><span class="hs-identifier hs-var">TIObject</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ObjectInfo"><span class="hs-identifier hs-type">ObjectInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361946"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeInfo"><span class="hs-identifier hs-type">TypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361946"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">'</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Output"><span class="hs-identifier hs-type">Output</span></a></span></span><span>
</span><span id="line-526"></span><span>  </span><span id="local-6989586621689361944"><span id="TIInterface"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIInterface"><span class="hs-identifier hs-var">TIInterface</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InterfaceInfo"><span class="hs-identifier hs-type">InterfaceInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361944"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeInfo"><span class="hs-identifier hs-type">TypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361944"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">'</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Output"><span class="hs-identifier hs-type">Output</span></a></span></span><span>
</span><span id="line-527"></span><span>  </span><span id="local-6989586621689361942"><span id="TIUnion"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIUnion"><span class="hs-identifier hs-var">TIUnion</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#UnionInfo"><span class="hs-identifier hs-type">UnionInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361942"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeInfo"><span class="hs-identifier hs-type">TypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361942"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">'</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Output"><span class="hs-identifier hs-type">Output</span></a></span></span><span>
</span><span id="line-528"></span><span>
</span><span id="line-529"></span><span class="hs-comment">-- Public interface enforcing invariants</span><span>
</span><span id="line-530"></span><span class="hs-keyword">pattern</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIEnum"><span class="hs-identifier hs-type">TIEnum</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621689362248"><span class="annot"><a href="#local-6989586621689362248"><span class="hs-identifier hs-type">origin</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621689362247"><span class="annot"><a href="#local-6989586621689362247"><span class="hs-identifier hs-type">k</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Kind"><span class="hs-identifier hs-type">Kind</span></a></span><span class="hs-special">)</span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621689362247"><span class="hs-identifier hs-type">k</span></a></span><span> </span><span class="annot"><span class="hs-glyph hs-type">~</span></span><span> </span><span class="hs-special">'</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Both"><span class="hs-identifier hs-type">Both</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NonEmpty</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362248"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#EnumValueInfo"><span class="hs-identifier hs-type">EnumValueInfo</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeInfo"><span class="hs-identifier hs-type">TypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362248"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362247"><span class="hs-identifier hs-type">k</span></a></span><span>
</span><span id="line-531"></span><span class="hs-keyword">pattern</span><span> </span><span id="%24bTIEnum"><span id="%24mTIEnum"><span id="TIEnum"><span class="annot"><span class="annottext">$bTIEnum :: NonEmpty (Definition origin EnumValueInfo) -&gt; TypeInfo origin k
$mTIEnum :: forall r origin (k :: Kind).
TypeInfo origin k
-&gt; ((k ~ 'Both) =&gt; NonEmpty (Definition origin EnumValueInfo) -&gt; r)
-&gt; (Void# -&gt; r)
-&gt; r
</span><a href="Hasura.GraphQL.Parser.Schema.html#%24bTIEnum"><span class="hs-identifier hs-var hs-var hs-var hs-var">TIEnum</span></a></span></span></span></span><span> </span><span class="annot"><a href="#local-6989586621689361774"><span class="hs-identifier hs-type">xs</span></a></span><span> </span><span class="hs-glyph">&lt;-</span><span>
</span><span id="line-532"></span><span>  </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIEnum__"><span class="hs-identifier hs-type">TIEnum__</span></a></span><span> </span><span id="local-6989586621689361774"><span class="annot"><a href="#local-6989586621689361774"><span class="hs-identifier hs-var">xs</span></a></span></span><span>
</span><span id="line-533"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-534"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIEnum"><span class="hs-identifier hs-var">TIEnum</span></a></span><span> </span><span id="local-6989586621689361773"><span class="annot"><span class="annottext">NonEmpty (Definition origin EnumValueInfo)
</span><a href="#local-6989586621689361773"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NonEmpty (Definition origin EnumValueInfo) -&gt; TypeInfo origin 'Both
forall origin.
NonEmpty (Definition origin EnumValueInfo) -&gt; TypeInfo origin 'Both
</span><a href="Hasura.GraphQL.Parser.Schema.html#TIEnum__"><span class="hs-identifier hs-var">TIEnum__</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Definition origin EnumValueInfo -&gt; Name)
-&gt; NonEmpty (Definition origin EnumValueInfo)
-&gt; NonEmpty (Definition origin EnumValueInfo)
forall o a. Ord o =&gt; (a -&gt; o) -&gt; NonEmpty a -&gt; NonEmpty a
</span><span class="hs-identifier hs-var">NE.sortWith</span></span><span> </span><span class="annot"><span class="annottext">Definition origin EnumValueInfo -&gt; Name
forall origin a. Definition origin a -&gt; Name
</span><a href="Hasura.GraphQL.Parser.Schema.html#dName"><span class="hs-identifier hs-var hs-var">dName</span></a></span><span> </span><span class="annot"><span class="annottext">NonEmpty (Definition origin EnumValueInfo)
</span><a href="#local-6989586621689361773"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-535"></span><span>
</span><span id="line-536"></span><span class="hs-pragma">{-# COMPLETE</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIScalar"><span class="hs-pragma hs-type">TIScalar</span></a></span><span class="hs-pragma">,</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIEnum"><span class="hs-pragma hs-type">TIEnum</span></a></span><span class="hs-pragma">,</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIInputObject"><span class="hs-pragma hs-type">TIInputObject</span></a></span><span class="hs-pragma">,</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIObject"><span class="hs-pragma hs-type">TIObject</span></a></span><span class="hs-pragma">,</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIInterface"><span class="hs-pragma hs-type">TIInterface</span></a></span><span class="hs-pragma">,</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIUnion"><span class="hs-pragma hs-type">TIUnion</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-537"></span><span>
</span><span id="line-538"></span><span id="local-6989586621689361770"><span id="local-6989586621689361771"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621689361767"><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeInfo"><span class="hs-identifier hs-type">TypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361771"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361770"><span class="hs-identifier hs-type">k</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-539"></span><span>  </span><span id="local-6989586621689361766"><span class="annot"><span class="annottext">== :: TypeInfo origin k -&gt; TypeInfo origin k -&gt; Bool
</span><span class="hs-operator hs-var hs-var hs-var hs-var">(==)</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TypeInfo origin k -&gt; TypeInfo origin k -&gt; Bool
forall origin (k1 :: Kind) (k2 :: Kind).
TypeInfo origin k1 -&gt; TypeInfo origin k2 -&gt; Bool
</span><a href="Hasura.GraphQL.Parser.Schema.html#eqTypeInfo"><span class="hs-identifier hs-var">eqTypeInfo</span></a></span></span></span><span>
</span><span id="line-540"></span><span>
</span><span id="line-541"></span><span class="hs-comment">-- | Like '==', but can compare 'TypeInfo's of different kinds.</span><span>
</span><span id="line-542"></span><span id="local-6989586621689362315"><span id="local-6989586621689362316"><span id="local-6989586621689362317"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#eqTypeInfo"><span class="hs-identifier hs-type">eqTypeInfo</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeInfo"><span class="hs-identifier hs-type">TypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362317"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362316"><span class="hs-identifier hs-type">k1</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeInfo"><span class="hs-identifier hs-type">TypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362317"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362315"><span class="hs-identifier hs-type">k2</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span></span><span>
</span><span id="line-543"></span><span id="eqTypeInfo"><span class="annot"><span class="annottext">eqTypeInfo :: TypeInfo origin k1 -&gt; TypeInfo origin k2 -&gt; Bool
</span><a href="Hasura.GraphQL.Parser.Schema.html#eqTypeInfo"><span class="hs-identifier hs-var hs-var">eqTypeInfo</span></a></span></span><span> </span><span class="annot"><span class="annottext">TypeInfo origin k1
</span><a href="Hasura.GraphQL.Parser.Schema.html#TIScalar"><span class="hs-identifier hs-var">TIScalar</span></a></span><span> </span><span class="annot"><span class="annottext">TypeInfo origin k2
</span><a href="Hasura.GraphQL.Parser.Schema.html#TIScalar"><span class="hs-identifier hs-var">TIScalar</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-544"></span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#eqTypeInfo"><span class="hs-identifier hs-var">eqTypeInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIEnum"><span class="hs-identifier hs-type">TIEnum</span></a></span><span> </span><span id="local-6989586621689361765"><span class="annot"><span class="annottext">NonEmpty (Definition origin EnumValueInfo)
</span><a href="#local-6989586621689361765"><span class="hs-identifier hs-var">values1</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIEnum"><span class="hs-identifier hs-type">TIEnum</span></a></span><span> </span><span id="local-6989586621689361764"><span class="annot"><span class="annottext">NonEmpty (Definition origin EnumValueInfo)
</span><a href="#local-6989586621689361764"><span class="hs-identifier hs-var">values2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NonEmpty (Definition origin EnumValueInfo)
</span><a href="#local-6989586621689361765"><span class="hs-identifier hs-var">values1</span></a></span><span> </span><span class="annot"><span class="annottext">NonEmpty (Definition origin EnumValueInfo)
-&gt; NonEmpty (Definition origin EnumValueInfo) -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">NonEmpty (Definition origin EnumValueInfo)
</span><a href="#local-6989586621689361764"><span class="hs-identifier hs-var">values2</span></a></span><span>
</span><span id="line-545"></span><span class="hs-comment">-- NB the case for input objects currently has quadratic complexity, which is</span><span>
</span><span id="line-546"></span><span class="hs-comment">-- probably avoidable. HashSets should be able to get this down to</span><span>
</span><span id="line-547"></span><span class="hs-comment">-- O(n*log(n)). But this requires writing some Hashable instances by hand</span><span>
</span><span id="line-548"></span><span class="hs-comment">-- because we use some existential types and GADTs.</span><span>
</span><span id="line-549"></span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#eqTypeInfo"><span class="hs-identifier hs-var">eqTypeInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIInputObject"><span class="hs-identifier hs-type">TIInputObject</span></a></span><span> </span><span id="local-6989586621689361763"><span class="annot"><span class="annottext">InputObjectInfo origin
</span><a href="#local-6989586621689361763"><span class="hs-identifier hs-var">ioi1</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIInputObject"><span class="hs-identifier hs-type">TIInputObject</span></a></span><span> </span><span id="local-6989586621689361762"><span class="annot"><span class="annottext">InputObjectInfo origin
</span><a href="#local-6989586621689361762"><span class="hs-identifier hs-var">ioi2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">InputObjectInfo origin
</span><a href="#local-6989586621689361763"><span class="hs-identifier hs-var">ioi1</span></a></span><span> </span><span class="annot"><span class="annottext">InputObjectInfo origin -&gt; InputObjectInfo origin -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">InputObjectInfo origin
</span><a href="#local-6989586621689361762"><span class="hs-identifier hs-var">ioi2</span></a></span><span>
</span><span id="line-550"></span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#eqTypeInfo"><span class="hs-identifier hs-var">eqTypeInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIObject"><span class="hs-identifier hs-type">TIObject</span></a></span><span> </span><span id="local-6989586621689361761"><span class="annot"><span class="annottext">ObjectInfo origin
</span><a href="#local-6989586621689361761"><span class="hs-identifier hs-var">oi1</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIObject"><span class="hs-identifier hs-type">TIObject</span></a></span><span> </span><span id="local-6989586621689361760"><span class="annot"><span class="annottext">ObjectInfo origin
</span><a href="#local-6989586621689361760"><span class="hs-identifier hs-var">oi2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ObjectInfo origin
</span><a href="#local-6989586621689361761"><span class="hs-identifier hs-var">oi1</span></a></span><span> </span><span class="annot"><span class="annottext">ObjectInfo origin -&gt; ObjectInfo origin -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">ObjectInfo origin
</span><a href="#local-6989586621689361760"><span class="hs-identifier hs-var">oi2</span></a></span><span>
</span><span id="line-551"></span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#eqTypeInfo"><span class="hs-identifier hs-var">eqTypeInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIInterface"><span class="hs-identifier hs-type">TIInterface</span></a></span><span> </span><span id="local-6989586621689361759"><span class="annot"><span class="annottext">InterfaceInfo origin
</span><a href="#local-6989586621689361759"><span class="hs-identifier hs-var">ii1</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIInterface"><span class="hs-identifier hs-type">TIInterface</span></a></span><span> </span><span id="local-6989586621689361758"><span class="annot"><span class="annottext">InterfaceInfo origin
</span><a href="#local-6989586621689361758"><span class="hs-identifier hs-var">ii2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">InterfaceInfo origin
</span><a href="#local-6989586621689361759"><span class="hs-identifier hs-var">ii1</span></a></span><span> </span><span class="annot"><span class="annottext">InterfaceInfo origin -&gt; InterfaceInfo origin -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">InterfaceInfo origin
</span><a href="#local-6989586621689361758"><span class="hs-identifier hs-var">ii2</span></a></span><span>
</span><span id="line-552"></span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#eqTypeInfo"><span class="hs-identifier hs-var">eqTypeInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIUnion"><span class="hs-identifier hs-type">TIUnion</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#UnionInfo"><span class="hs-identifier hs-type">UnionInfo</span></a></span><span> </span><span id="local-6989586621689361757"><span class="annot"><span class="annottext">[Definition origin (ObjectInfo origin)]
</span><a href="#local-6989586621689361757"><span class="hs-identifier hs-var">objects1</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIUnion"><span class="hs-identifier hs-type">TIUnion</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#UnionInfo"><span class="hs-identifier hs-type">UnionInfo</span></a></span><span> </span><span id="local-6989586621689361756"><span class="annot"><span class="annottext">[Definition origin (ObjectInfo origin)]
</span><a href="#local-6989586621689361756"><span class="hs-identifier hs-var">objects2</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-553"></span><span>  </span><span class="annot"><span class="annottext">[Definition origin (ObjectInfo origin)]
-&gt; [Definition origin (ObjectInfo origin)] -&gt; Bool
forall origin a.
[Definition origin a] -&gt; [Definition origin a] -&gt; Bool
</span><a href="Hasura.GraphQL.Parser.Schema.html#eqByName"><span class="hs-identifier hs-var">eqByName</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (ObjectInfo origin)]
</span><a href="#local-6989586621689361757"><span class="hs-identifier hs-var">objects1</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (ObjectInfo origin)]
</span><a href="#local-6989586621689361756"><span class="hs-identifier hs-var">objects2</span></a></span><span>
</span><span id="line-554"></span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#eqTypeInfo"><span class="hs-identifier hs-var">eqTypeInfo</span></a></span><span> </span><span class="annot"><span class="annottext">TypeInfo origin k1
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">TypeInfo origin k2
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-555"></span><span>
</span><span id="line-556"></span><span id="local-6989586621689362230"><span id="local-6989586621689362231"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#getTypeInfo"><span class="hs-identifier hs-type">getTypeInfo</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362231"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362230"><span class="hs-identifier hs-type">k</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362231"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeInfo"><span class="hs-identifier hs-type">TypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362231"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362230"><span class="hs-identifier hs-type">k</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-557"></span><span id="getTypeInfo"><span class="annot"><span class="annottext">getTypeInfo :: Type origin k -&gt; Definition origin (TypeInfo origin k)
</span><a href="Hasura.GraphQL.Parser.Schema.html#getTypeInfo"><span class="hs-identifier hs-var hs-var">getTypeInfo</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TNamed"><span class="hs-identifier hs-type">TNamed</span></a></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621689361755"><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
</span><a href="#local-6989586621689361755"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
</span><a href="#local-6989586621689361755"><span class="hs-identifier hs-var">d</span></a></span><span>
</span><span id="line-558"></span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#getTypeInfo"><span class="hs-identifier hs-var">getTypeInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TList"><span class="hs-identifier hs-type">TList</span></a></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621689361754"><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361754"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type origin k -&gt; Definition origin (TypeInfo origin k)
forall origin (k :: Kind).
Type origin k -&gt; Definition origin (TypeInfo origin k)
</span><a href="Hasura.GraphQL.Parser.Schema.html#getTypeInfo"><span class="hs-identifier hs-var">getTypeInfo</span></a></span><span> </span><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361754"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-559"></span><span>
</span><span id="line-560"></span><span id="local-6989586621689361752"><span id="local-6989586621689361753"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#getObjectInfo"><span class="hs-identifier hs-type">getObjectInfo</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361753"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361752"><span class="hs-identifier hs-type">k</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361753"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ObjectInfo"><span class="hs-identifier hs-type">ObjectInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361753"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-561"></span><span id="getObjectInfo"><span class="annot"><span class="annottext">getObjectInfo :: Type origin k -&gt; Maybe (Definition origin (ObjectInfo origin))
</span><a href="Hasura.GraphQL.Parser.Schema.html#getObjectInfo"><span class="hs-identifier hs-var hs-var">getObjectInfo</span></a></span></span><span> </span><span id="local-6989586621689361751"><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361751"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type origin k -&gt; Definition origin (TypeInfo origin k)
forall origin (k :: Kind).
Type origin k -&gt; Definition origin (TypeInfo origin k)
</span><a href="Hasura.GraphQL.Parser.Schema.html#getTypeInfo"><span class="hs-identifier hs-var">getTypeInfo</span></a></span><span> </span><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361751"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-562"></span><span>  </span><span id="local-6989586621689361750"><span class="annot"><span class="annottext">d :: Definition origin (TypeInfo origin k)
</span><a href="#local-6989586621689361750"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="hs-special">{</span><span class="annot"><span class="annottext">dInfo :: forall origin a. Definition origin a -&gt; a
</span><a href="Hasura.GraphQL.Parser.Schema.html#dInfo"><span class="hs-identifier hs-var">dInfo</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIObject"><span class="hs-identifier hs-type">TIObject</span></a></span><span> </span><span id="local-6989586621689361747"><span class="annot"><span class="annottext">ObjectInfo origin
</span><a href="#local-6989586621689361747"><span class="hs-identifier hs-var">oi</span></a></span></span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Definition origin (ObjectInfo origin)
-&gt; Maybe (Definition origin (ObjectInfo origin))
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
</span><a href="#local-6989586621689361750"><span class="hs-identifier hs-var">d</span></a></span><span> </span><span class="hs-special">{</span><span class="annot"><span class="annottext">dInfo :: ObjectInfo origin
</span><a href="Hasura.GraphQL.Parser.Schema.html#dInfo"><span class="hs-identifier hs-var">dInfo</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ObjectInfo origin
</span><a href="#local-6989586621689361747"><span class="hs-identifier hs-var">oi</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-563"></span><span>  </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe (Definition origin (ObjectInfo origin))
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-564"></span><span>
</span><span id="line-565"></span><span id="local-6989586621689361745"><span id="local-6989586621689361746"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#getInterfaceInfo"><span class="hs-identifier hs-type">getInterfaceInfo</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361746"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361745"><span class="hs-identifier hs-type">k</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361746"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InterfaceInfo"><span class="hs-identifier hs-type">InterfaceInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361746"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-566"></span><span id="getInterfaceInfo"><span class="annot"><span class="annottext">getInterfaceInfo :: Type origin k -&gt; Maybe (Definition origin (InterfaceInfo origin))
</span><a href="Hasura.GraphQL.Parser.Schema.html#getInterfaceInfo"><span class="hs-identifier hs-var hs-var">getInterfaceInfo</span></a></span></span><span> </span><span id="local-6989586621689361744"><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361744"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type origin k -&gt; Definition origin (TypeInfo origin k)
forall origin (k :: Kind).
Type origin k -&gt; Definition origin (TypeInfo origin k)
</span><a href="Hasura.GraphQL.Parser.Schema.html#getTypeInfo"><span class="hs-identifier hs-var">getTypeInfo</span></a></span><span> </span><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361744"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-567"></span><span>  </span><span id="local-6989586621689361743"><span class="annot"><span class="annottext">d :: Definition origin (TypeInfo origin k)
</span><a href="#local-6989586621689361743"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="hs-special">{</span><span class="annot"><span class="annottext">dInfo :: forall origin a. Definition origin a -&gt; a
</span><a href="Hasura.GraphQL.Parser.Schema.html#dInfo"><span class="hs-identifier hs-var">dInfo</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIInterface"><span class="hs-identifier hs-type">TIInterface</span></a></span><span> </span><span id="local-6989586621689361742"><span class="annot"><span class="annottext">InterfaceInfo origin
</span><a href="#local-6989586621689361742"><span class="hs-identifier hs-var">ii</span></a></span></span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Definition origin (InterfaceInfo origin)
-&gt; Maybe (Definition origin (InterfaceInfo origin))
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
</span><a href="#local-6989586621689361743"><span class="hs-identifier hs-var">d</span></a></span><span> </span><span class="hs-special">{</span><span class="annot"><span class="annottext">dInfo :: InterfaceInfo origin
</span><a href="Hasura.GraphQL.Parser.Schema.html#dInfo"><span class="hs-identifier hs-var">dInfo</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">InterfaceInfo origin
</span><a href="#local-6989586621689361742"><span class="hs-identifier hs-var">ii</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-568"></span><span>  </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe (Definition origin (InterfaceInfo origin))
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-569"></span><span>
</span><span id="line-570"></span><span class="hs-keyword">data</span><span> </span><span id="SomeDefinitionTypeInfo"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#SomeDefinitionTypeInfo"><span class="hs-identifier hs-var">SomeDefinitionTypeInfo</span></a></span></span><span> </span><span id="local-6989586621689361979"><span class="annot"><a href="#local-6989586621689361979"><span class="hs-identifier hs-type">origin</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621689361978"><span class="annot"><a href="#local-6989586621689361978"><span class="hs-identifier hs-type">k</span></a></span></span><span class="hs-operator">.</span><span> </span><span id="SomeDefinitionTypeInfo"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#SomeDefinitionTypeInfo"><span class="hs-identifier hs-var">SomeDefinitionTypeInfo</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361979"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeInfo"><span class="hs-identifier hs-type">TypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361979"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361978"><span class="hs-identifier hs-type">k</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-571"></span><span>
</span><span id="line-572"></span><span id="local-6989586621689361740"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Names.html#HasName"><span class="hs-identifier hs-type">HasName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#SomeDefinitionTypeInfo"><span class="hs-identifier hs-type">SomeDefinitionTypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361740"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-573"></span><span>  </span><span id="local-6989586621689361738"><span class="annot"><span class="annottext">getName :: SomeDefinitionTypeInfo origin -&gt; Name
</span><a href="#local-6989586621689361738"><span class="hs-identifier hs-var hs-var hs-var hs-var">getName</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#SomeDefinitionTypeInfo"><span class="hs-identifier hs-type">SomeDefinitionTypeInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span id="local-6989586621689361737"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361737"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe Description
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe origin
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Directive Void]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">TypeInfo origin k
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361737"><span class="hs-identifier hs-var">n</span></a></span></span><span>
</span><span id="line-574"></span><span>
</span><span id="line-575"></span><span id="local-6989586621689361736"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621689361733"><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#SomeDefinitionTypeInfo"><span class="hs-identifier hs-type">SomeDefinitionTypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361736"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-576"></span><span>  </span><span class="hs-comment">-- Same as instance Eq Definition</span><span>
</span><span id="line-577"></span><span>  </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#SomeDefinitionTypeInfo"><span class="hs-identifier hs-type">SomeDefinitionTypeInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span id="local-6989586621689361732"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361732"><span class="hs-identifier hs-var">name1</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe Description
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe origin
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Directive Void]
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621689361731"><span class="annot"><span class="annottext">TypeInfo origin k
</span><a href="#local-6989586621689361731"><span class="hs-identifier hs-var">ti1</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-578"></span><span>    </span><span id="local-6989586621689361730"><span class="annot"><span class="annottext">== :: SomeDefinitionTypeInfo origin
-&gt; SomeDefinitionTypeInfo origin -&gt; Bool
</span><span class="hs-operator hs-var hs-var hs-var hs-var">==</span></span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#SomeDefinitionTypeInfo"><span class="hs-identifier hs-type">SomeDefinitionTypeInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span id="local-6989586621689361729"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361729"><span class="hs-identifier hs-var">name2</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe Description
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe origin
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Directive Void]
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621689361728"><span class="annot"><span class="annottext">TypeInfo origin k
</span><a href="#local-6989586621689361728"><span class="hs-identifier hs-var">ti2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-579"></span><span>      </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361732"><span class="hs-identifier hs-var">name1</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361729"><span class="hs-identifier hs-var">name2</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">TypeInfo origin k -&gt; TypeInfo origin k -&gt; Bool
forall origin (k1 :: Kind) (k2 :: Kind).
TypeInfo origin k1 -&gt; TypeInfo origin k2 -&gt; Bool
</span><a href="Hasura.GraphQL.Parser.Schema.html#eqTypeInfo"><span class="hs-identifier hs-var">eqTypeInfo</span></a></span><span> </span><span class="annot"><span class="annottext">TypeInfo origin k
</span><a href="#local-6989586621689361731"><span class="hs-identifier hs-var">ti1</span></a></span><span> </span><span class="annot"><span class="annottext">TypeInfo origin k
</span><a href="#local-6989586621689361728"><span class="hs-identifier hs-var">ti2</span></a></span></span><span>
</span><span id="line-580"></span><span>
</span><span id="line-581"></span><span id="local-6989586621689361726"><span id="local-6989586621689361727"></span></span><span class="hs-keyword">data</span><span> </span><span id="Definition"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-var">Definition</span></a></span></span><span> </span><span id="local-6989586621689362285"><span class="annot"><a href="#local-6989586621689362285"><span class="hs-identifier hs-type">origin</span></a></span></span><span> </span><span id="local-6989586621689362284"><span class="annot"><a href="#local-6989586621689362284"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Definition"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-var">Definition</span></a></span></span><span>
</span><span id="line-582"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="dName"><span class="annot"><span class="annottext">Definition origin a -&gt; Name
</span><a href="Hasura.GraphQL.Parser.Schema.html#dName"><span class="hs-identifier hs-var hs-var">dName</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span>
</span><span id="line-583"></span><span>    </span><span id="dDescription"><span class="annot"><span class="annottext">Definition origin a -&gt; Maybe Description
</span><a href="Hasura.GraphQL.Parser.Schema.html#dDescription"><span class="hs-identifier hs-var hs-var">dDescription</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Description</span></span><span class="hs-special">,</span><span>
</span><span id="line-584"></span><span>    </span><span class="hs-comment">-- | What piece of metadata was this fragment of GraphQL type information</span><span>
</span><span id="line-585"></span><span>    </span><span class="hs-comment">-- from?  See also 'Hasura.GraphQL.Schema.Parser'.</span><span>
</span><span id="line-586"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-587"></span><span>    </span><span class="hs-comment">-- 'Nothing' can represent a couple of scenarios:</span><span>
</span><span id="line-588"></span><span>    </span><span class="hs-comment">-- 1. This is a native part of the GraphQL spec, e.g. the '__Type'</span><span>
</span><span id="line-589"></span><span>    </span><span class="hs-comment">--    introspection type</span><span>
</span><span id="line-590"></span><span>    </span><span class="hs-comment">-- 2. This is a native part of HGE, e.g. our scalar types and Relay-related</span><span>
</span><span id="line-591"></span><span>    </span><span class="hs-comment">--    types</span><span>
</span><span id="line-592"></span><span>    </span><span class="hs-comment">-- 3. We don't have a clear origin, because</span><span>
</span><span id="line-593"></span><span>    </span><span class="hs-comment">--    a. Semantically there is no clear origin because it arose from the</span><span>
</span><span id="line-594"></span><span>    </span><span class="hs-comment">--       combination of several things</span><span>
</span><span id="line-595"></span><span>    </span><span class="hs-comment">--    b. We generated this 'Definition' in a context where origin</span><span>
</span><span id="line-596"></span><span>    </span><span class="hs-comment">--       information was no longer in scope</span><span>
</span><span id="line-597"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-598"></span><span>    </span><span class="hs-comment">-- Maybe, at some point, it makes sense to represent the above options more</span><span>
</span><span id="line-599"></span><span>    </span><span class="hs-comment">-- accurately in the type of 'dOrigin'.</span><span>
</span><span id="line-600"></span><span>    </span><span id="dOrigin"><span class="annot"><span class="annottext">Definition origin a -&gt; Maybe origin
</span><a href="Hasura.GraphQL.Parser.Schema.html#dOrigin"><span class="hs-identifier hs-var hs-var">dOrigin</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621689362285"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-601"></span><span>    </span><span class="hs-comment">-- | The directives for this object.</span><span>
</span><span id="line-602"></span><span>    </span><span id="dDirectives"><span class="annot"><span class="annottext">Definition origin a -&gt; [Directive Void]
</span><a href="Hasura.GraphQL.Parser.Schema.html#dDirectives"><span class="hs-identifier hs-var hs-var">dDirectives</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">G.Directive</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Void</span></span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-603"></span><span>    </span><span class="hs-comment">-- | Lazy to allow mutually-recursive type definitions.</span><span>
</span><span id="line-604"></span><span>    </span><span id="dInfo"><span class="annot"><span class="annottext">Definition origin a -&gt; a
</span><a href="Hasura.GraphQL.Parser.Schema.html#dInfo"><span class="hs-identifier hs-var hs-var">dInfo</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">~</span><span class="annot"><a href="#local-6989586621689362284"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-605"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-606"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621689361719"><span id="local-6989586621689361721"><span class="annot"><span class="annottext">a -&gt; Definition origin b -&gt; Definition origin a
(a -&gt; b) -&gt; Definition origin a -&gt; Definition origin b
(forall a b.
 (a -&gt; b) -&gt; Definition origin a -&gt; Definition origin b)
-&gt; (forall a b. a -&gt; Definition origin b -&gt; Definition origin a)
-&gt; Functor (Definition origin)
forall a b. a -&gt; Definition origin b -&gt; Definition origin a
forall a b. (a -&gt; b) -&gt; Definition origin a -&gt; Definition origin b
forall origin a b. a -&gt; Definition origin b -&gt; Definition origin a
forall origin a b.
(a -&gt; b) -&gt; Definition origin a -&gt; Definition origin b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: a -&gt; Definition origin b -&gt; Definition origin a
$c&lt;$ :: forall origin a b. a -&gt; Definition origin b -&gt; Definition origin a
fmap :: (a -&gt; b) -&gt; Definition origin a -&gt; Definition origin b
$cfmap :: forall origin a b.
(a -&gt; b) -&gt; Definition origin a -&gt; Definition origin b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621689361684"><span id="local-6989586621689361686"><span id="local-6989586621689361688"><span id="local-6989586621689361690"><span id="local-6989586621689361692"><span id="local-6989586621689361694"><span id="local-6989586621689361696"><span id="local-6989586621689361698"><span id="local-6989586621689361700"><span id="local-6989586621689361702"><span id="local-6989586621689361704"><span id="local-6989586621689361706"><span id="local-6989586621689361708"><span id="local-6989586621689361710"><span id="local-6989586621689361712"><span id="local-6989586621689361714"><span id="local-6989586621689361716"><span class="annot"><span class="annottext">Definition origin a -&gt; Bool
(a -&gt; m) -&gt; Definition origin a -&gt; m
(a -&gt; b -&gt; b) -&gt; b -&gt; Definition origin a -&gt; b
(forall m. Monoid m =&gt; Definition origin m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Definition origin a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Definition origin a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Definition origin a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Definition origin a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Definition origin a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Definition origin a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Definition origin a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Definition origin a -&gt; a)
-&gt; (forall a. Definition origin a -&gt; [a])
-&gt; (forall a. Definition origin a -&gt; Bool)
-&gt; (forall a. Definition origin a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; Definition origin a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; Definition origin a -&gt; a)
-&gt; (forall a. Ord a =&gt; Definition origin a -&gt; a)
-&gt; (forall a. Num a =&gt; Definition origin a -&gt; a)
-&gt; (forall a. Num a =&gt; Definition origin a -&gt; a)
-&gt; Foldable (Definition origin)
forall a. Eq a =&gt; a -&gt; Definition origin a -&gt; Bool
forall a. Num a =&gt; Definition origin a -&gt; a
forall a. Ord a =&gt; Definition origin a -&gt; a
forall m. Monoid m =&gt; Definition origin m -&gt; m
forall a. Definition origin a -&gt; Bool
forall a. Definition origin a -&gt; Int
forall a. Definition origin a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Definition origin a -&gt; a
forall origin a. Eq a =&gt; a -&gt; Definition origin a -&gt; Bool
forall origin a. Num a =&gt; Definition origin a -&gt; a
forall origin a. Ord a =&gt; Definition origin a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Definition origin a -&gt; m
forall origin m. Monoid m =&gt; Definition origin m -&gt; m
forall origin a. Definition origin a -&gt; Bool
forall origin a. Definition origin a -&gt; Int
forall origin a. Definition origin a -&gt; [a]
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Definition origin a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Definition origin a -&gt; b
forall origin a. (a -&gt; a -&gt; a) -&gt; Definition origin a -&gt; a
forall origin m a. Monoid m =&gt; (a -&gt; m) -&gt; Definition origin a -&gt; m
forall origin b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Definition origin a -&gt; b
forall origin a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Definition origin a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: Definition origin a -&gt; a
$cproduct :: forall origin a. Num a =&gt; Definition origin a -&gt; a
sum :: Definition origin a -&gt; a
$csum :: forall origin a. Num a =&gt; Definition origin a -&gt; a
minimum :: Definition origin a -&gt; a
$cminimum :: forall origin a. Ord a =&gt; Definition origin a -&gt; a
maximum :: Definition origin a -&gt; a
$cmaximum :: forall origin a. Ord a =&gt; Definition origin a -&gt; a
elem :: a -&gt; Definition origin a -&gt; Bool
$celem :: forall origin a. Eq a =&gt; a -&gt; Definition origin a -&gt; Bool
length :: Definition origin a -&gt; Int
$clength :: forall origin a. Definition origin a -&gt; Int
null :: Definition origin a -&gt; Bool
$cnull :: forall origin a. Definition origin a -&gt; Bool
toList :: Definition origin a -&gt; [a]
$ctoList :: forall origin a. Definition origin a -&gt; [a]
foldl1 :: (a -&gt; a -&gt; a) -&gt; Definition origin a -&gt; a
$cfoldl1 :: forall origin a. (a -&gt; a -&gt; a) -&gt; Definition origin a -&gt; a
foldr1 :: (a -&gt; a -&gt; a) -&gt; Definition origin a -&gt; a
$cfoldr1 :: forall origin a. (a -&gt; a -&gt; a) -&gt; Definition origin a -&gt; a
foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; Definition origin a -&gt; b
$cfoldl' :: forall origin b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Definition origin a -&gt; b
foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; Definition origin a -&gt; b
$cfoldl :: forall origin b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Definition origin a -&gt; b
foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; Definition origin a -&gt; b
$cfoldr' :: forall origin a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Definition origin a -&gt; b
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; Definition origin a -&gt; b
$cfoldr :: forall origin a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Definition origin a -&gt; b
foldMap' :: (a -&gt; m) -&gt; Definition origin a -&gt; m
$cfoldMap' :: forall origin m a. Monoid m =&gt; (a -&gt; m) -&gt; Definition origin a -&gt; m
foldMap :: (a -&gt; m) -&gt; Definition origin a -&gt; m
$cfoldMap :: forall origin m a. Monoid m =&gt; (a -&gt; m) -&gt; Definition origin a -&gt; m
fold :: Definition origin m -&gt; m
$cfold :: forall origin m. Monoid m =&gt; Definition origin m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621689361673"><span id="local-6989586621689361675"><span id="local-6989586621689361677"><span id="local-6989586621689361679"><span class="annot"><span class="annottext">Functor (Definition origin)
Foldable (Definition origin)
Functor (Definition origin)
-&gt; Foldable (Definition origin)
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; Definition origin a -&gt; f (Definition origin b))
-&gt; (forall (f :: * -&gt; *) a.
    Applicative f =&gt;
    Definition origin (f a) -&gt; f (Definition origin a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; Definition origin a -&gt; m (Definition origin b))
-&gt; (forall (m :: * -&gt; *) a.
    Monad m =&gt;
    Definition origin (m a) -&gt; m (Definition origin a))
-&gt; Traversable (Definition origin)
(a -&gt; f b) -&gt; Definition origin a -&gt; f (Definition origin b)
forall origin. Functor (Definition origin)
forall origin. Foldable (Definition origin)
forall origin (m :: * -&gt; *) a.
Monad m =&gt;
Definition origin (m a) -&gt; m (Definition origin a)
forall origin (f :: * -&gt; *) a.
Applicative f =&gt;
Definition origin (f a) -&gt; f (Definition origin a)
forall origin (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Definition origin a -&gt; m (Definition origin b)
forall origin (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Definition origin a -&gt; f (Definition origin b)
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
Definition origin (m a) -&gt; m (Definition origin a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Definition origin (f a) -&gt; f (Definition origin a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Definition origin a -&gt; m (Definition origin b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Definition origin a -&gt; f (Definition origin b)
sequence :: Definition origin (m a) -&gt; m (Definition origin a)
$csequence :: forall origin (m :: * -&gt; *) a.
Monad m =&gt;
Definition origin (m a) -&gt; m (Definition origin a)
mapM :: (a -&gt; m b) -&gt; Definition origin a -&gt; m (Definition origin b)
$cmapM :: forall origin (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Definition origin a -&gt; m (Definition origin b)
sequenceA :: Definition origin (f a) -&gt; f (Definition origin a)
$csequenceA :: forall origin (f :: * -&gt; *) a.
Applicative f =&gt;
Definition origin (f a) -&gt; f (Definition origin a)
traverse :: (a -&gt; f b) -&gt; Definition origin a -&gt; f (Definition origin b)
$ctraverse :: forall origin (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Definition origin a -&gt; f (Definition origin b)
$cp2Traversable :: forall origin. Foldable (Definition origin)
$cp1Traversable :: forall origin. Functor (Definition origin)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. Definition origin a -&gt; Rep (Definition origin a) x)
-&gt; (forall x. Rep (Definition origin a) x -&gt; Definition origin a)
-&gt; Generic (Definition origin a)
forall x. Rep (Definition origin a) x -&gt; Definition origin a
forall x. Definition origin a -&gt; Rep (Definition origin a) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall origin a x.
Rep (Definition origin a) x -&gt; Definition origin a
forall origin a x.
Definition origin a -&gt; Rep (Definition origin a) x
$cto :: forall origin a x.
Rep (Definition origin a) x -&gt; Definition origin a
$cfrom :: forall origin a x.
Definition origin a -&gt; Rep (Definition origin a) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-607"></span><span>
</span><span id="line-608"></span><span id="local-6989586621689361667"><span id="local-6989586621689361668"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621689361664"><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621689361668"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361667"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361668"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-609"></span><span>  </span><span id="local-6989586621689361662"><span class="annot"><span class="annottext">hashWithSalt :: Int -&gt; Definition origin a -&gt; Int
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">hashWithSalt</span></span></span><span> </span><span id="local-6989586621689361660"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621689361660"><span class="hs-identifier hs-var">salt</span></a></span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="hs-special">{</span><span id="local-6989586621689361655"><span id="local-6989586621689361656"><span id="local-6989586621689361657"><span id="local-6989586621689361658"><span id="local-6989586621689361659"><span class="annot"><span class="annottext">a
[Directive Void]
Maybe origin
Maybe Description
Name
dInfo :: a
dDirectives :: [Directive Void]
dOrigin :: Maybe origin
dDescription :: Maybe Description
dName :: Name
dDirectives :: forall origin a. Definition origin a -&gt; [Directive Void]
dOrigin :: forall origin a. Definition origin a -&gt; Maybe origin
dDescription :: forall origin a. Definition origin a -&gt; Maybe Description
dInfo :: forall origin a. Definition origin a -&gt; a
dName :: forall origin a. Definition origin a -&gt; Name
</span><a href="#local-6989586621689361655"><span class="hs-glyph hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">..</span></a></span></span></span></span></span></span><span class="hs-special">}</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-610"></span><span>    </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621689361660"><span class="hs-identifier hs-var">salt</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Name -&gt; Int
forall a. Hashable a =&gt; Int -&gt; a -&gt; Int
</span><span class="hs-operator hs-var">`hashWithSalt`</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361659"><span class="hs-identifier hs-var">dName</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; a -&gt; Int
forall a. Hashable a =&gt; Int -&gt; a -&gt; Int
</span><span class="hs-operator hs-var">`hashWithSalt`</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621689361655"><span class="hs-identifier hs-var">dInfo</span></a></span></span></span><span>
</span><span id="line-611"></span><span>
</span><span id="line-612"></span><span id="local-6989586621689361653"><span id="local-6989586621689361654"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621689361650"><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621689361654"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361653"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361654"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-613"></span><span>  </span><span id="local-6989586621689361649"><span class="annot"><span class="annottext">== :: Definition origin a -&gt; Definition origin a -&gt; Bool
</span><span class="hs-operator hs-var hs-var hs-var hs-var">(==)</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Definition origin a -&gt; Definition origin a -&gt; Bool
forall (f :: * -&gt; *) a. (Eq1 f, Eq a) =&gt; f a -&gt; f a -&gt; Bool
</span><span class="hs-identifier hs-var">eq1</span></span></span></span><span>
</span><span id="line-614"></span><span>
</span><span id="line-615"></span><span id="local-6989586621689361647"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361647"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-616"></span><span>  </span><span id="local-6989586621689361644"><span class="annot"><span class="annottext">liftEq :: (a -&gt; b -&gt; Bool)
-&gt; Definition origin a -&gt; Definition origin b -&gt; Bool
</span><a href="#local-6989586621689361644"><span class="hs-identifier hs-var hs-var hs-var hs-var">liftEq</span></a></span></span><span>
</span><span id="line-617"></span><span>    </span><span id="local-6989586621689361643"><span class="annot"><span class="annottext">a -&gt; b -&gt; Bool
</span><a href="#local-6989586621689361643"><span class="hs-identifier hs-var">eq</span></a></span></span><span>
</span><span id="line-618"></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span id="local-6989586621689361642"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361642"><span class="hs-identifier hs-var">name1</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe Description
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe origin
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Directive Void]
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621689361641"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621689361641"><span class="hs-identifier hs-var">info1</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-619"></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span id="local-6989586621689361640"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361640"><span class="hs-identifier hs-var">name2</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe Description
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe origin
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Directive Void]
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621689361639"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621689361639"><span class="hs-identifier hs-var">info2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-620"></span><span>      </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361642"><span class="hs-identifier hs-var">name1</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361640"><span class="hs-identifier hs-var">name2</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; b -&gt; Bool
</span><a href="#local-6989586621689361643"><span class="hs-identifier hs-var">eq</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621689361641"><span class="hs-identifier hs-var">info1</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621689361639"><span class="hs-identifier hs-var">info2</span></a></span></span><span>
</span><span id="line-621"></span><span>
</span><span id="line-622"></span><span id="local-6989586621689361637"><span id="local-6989586621689361638"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Names.html#HasName"><span class="hs-identifier hs-type">HasName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361638"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361637"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-623"></span><span>  </span><span id="local-6989586621689361635"><span class="annot"><span class="annottext">getName :: Definition origin a -&gt; Name
</span><a href="#local-6989586621689361635"><span class="hs-identifier hs-var hs-var hs-var hs-var">getName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Definition origin a -&gt; Name
forall origin a. Definition origin a -&gt; Name
</span><a href="Hasura.GraphQL.Parser.Schema.html#dName"><span class="hs-identifier hs-var hs-var">dName</span></a></span></span></span><span>
</span><span id="line-624"></span><span>
</span><span id="line-625"></span><span class="hs-comment">-- | equivalent to, but faster than...</span><span>
</span><span id="line-626"></span><span class="hs-comment">--</span><span>
</span><span id="line-627"></span><span class="hs-comment">-- &gt; map dName x == map dName y</span><span>
</span><span id="line-628"></span><span id="local-6989586621689362281"><span id="local-6989586621689362282"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#eqByName"><span class="hs-identifier hs-type">eqByName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362282"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362281"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362282"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362281"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span><span>
</span><span id="line-629"></span><span id="eqByName"><span class="annot"><span class="annottext">eqByName :: [Definition origin a] -&gt; [Definition origin a] -&gt; Bool
</span><a href="Hasura.GraphQL.Parser.Schema.html#eqByName"><span class="hs-identifier hs-var hs-var">eqByName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Definition origin a -&gt; Definition origin a -&gt; Bool)
-&gt; [Definition origin a] -&gt; [Definition origin a] -&gt; Bool
forall (f :: * -&gt; *) a b.
Eq1 f =&gt;
(a -&gt; b -&gt; Bool) -&gt; f a -&gt; f b -&gt; Bool
</span><span class="hs-identifier hs-var">liftEq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">(==)</span></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Name -&gt; Bool)
-&gt; (Definition origin a -&gt; Name)
-&gt; Definition origin a
-&gt; Definition origin a
-&gt; Bool
forall b c a. (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c
</span><span class="hs-operator hs-var">`on`</span></span><span> </span><span class="annot"><span class="annottext">Definition origin a -&gt; Name
forall origin a. Definition origin a -&gt; Name
</span><a href="Hasura.GraphQL.Parser.Schema.html#dName"><span class="hs-identifier hs-var hs-var">dName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-630"></span><span>
</span><span id="line-631"></span><span class="hs-comment">-- | Enum values have no extra information except for the information common to</span><span>
</span><span id="line-632"></span><span class="hs-comment">-- all definitions, so this is just a placeholder for use as @'Definition'</span><span>
</span><span id="line-633"></span><span class="hs-comment">-- 'EnumValueInfo'@.</span><span>
</span><span id="line-634"></span><span id="local-6989586621689361633"><span id="local-6989586621689361634"></span></span><span class="hs-keyword">data</span><span> </span><span id="EnumValueInfo"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#EnumValueInfo"><span class="hs-identifier hs-var">EnumValueInfo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="EnumValueInfo"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#EnumValueInfo"><span class="hs-identifier hs-var">EnumValueInfo</span></a></span></span><span>
</span><span id="line-635"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621689361628"><span id="local-6989586621689361630"><span class="annot"><span class="annottext">EnumValueInfo -&gt; EnumValueInfo -&gt; Bool
(EnumValueInfo -&gt; EnumValueInfo -&gt; Bool)
-&gt; (EnumValueInfo -&gt; EnumValueInfo -&gt; Bool) -&gt; Eq EnumValueInfo
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: EnumValueInfo -&gt; EnumValueInfo -&gt; Bool
$c/= :: EnumValueInfo -&gt; EnumValueInfo -&gt; Bool
== :: EnumValueInfo -&gt; EnumValueInfo -&gt; Bool
$c== :: EnumValueInfo -&gt; EnumValueInfo -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. EnumValueInfo -&gt; Rep EnumValueInfo x)
-&gt; (forall x. Rep EnumValueInfo x -&gt; EnumValueInfo)
-&gt; Generic EnumValueInfo
forall x. Rep EnumValueInfo x -&gt; EnumValueInfo
forall x. EnumValueInfo -&gt; Rep EnumValueInfo x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep EnumValueInfo x -&gt; EnumValueInfo
$cfrom :: forall x. EnumValueInfo -&gt; Rep EnumValueInfo x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-636"></span><span>
</span><span id="line-637"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621689361622"><span id="local-6989586621689361624"><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#EnumValueInfo"><span class="hs-identifier hs-type">EnumValueInfo</span></a></span></span></span><span>
</span><span id="line-638"></span><span>
</span><span id="line-639"></span><span class="hs-keyword">data</span><span> </span><span id="InputFieldInfo"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputFieldInfo"><span class="hs-identifier hs-var">InputFieldInfo</span></a></span></span><span> </span><span id="local-6989586621689361621"><span class="annot"><a href="#local-6989586621689361621"><span class="hs-identifier hs-type">origin</span></a></span></span><span>
</span><span id="line-640"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- | An input field with a type and possibly a default value. If a default</span><span>
</span><span id="line-641"></span><span>    </span><span class="hs-comment">-- value is provided, it should be a valid value for the type.</span><span>
</span><span id="line-642"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-643"></span><span>    </span><span class="hs-comment">-- Note that a default value of 'VNull' is subtly different from having no</span><span>
</span><span id="line-644"></span><span>    </span><span class="hs-comment">-- default value at all. If no default value is provided (i.e. 'Nothing'),</span><span>
</span><span id="line-645"></span><span>    </span><span class="hs-comment">-- the GraphQL specification allows distinguishing provided @null@ values</span><span>
</span><span id="line-646"></span><span>    </span><span class="hs-comment">-- from values left completely absent; see Note [The value of omitted</span><span>
</span><span id="line-647"></span><span>    </span><span class="hs-comment">-- fields] in Hasura.GraphQL.Parser.Internal.Parser.</span><span>
</span><span id="line-648"></span><span>    </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621689361620"><span class="annot"><a href="#local-6989586621689361620"><span class="hs-identifier hs-type">k</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="hs-special">'</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Input"><span class="hs-identifier hs-type">Input</span></a></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#%3C%3A"><span class="hs-operator hs-type">&lt;:</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361620"><span class="hs-identifier hs-type">k</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span id="InputFieldInfo"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputFieldInfo"><span class="hs-identifier hs-var">InputFieldInfo</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361621"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361620"><span class="hs-identifier hs-type">k</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Value</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Void</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-649"></span><span>
</span><span id="line-650"></span><span id="local-6989586621689361618"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621689361615"><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputFieldInfo"><span class="hs-identifier hs-type">InputFieldInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361618"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-651"></span><span>  </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputFieldInfo"><span class="hs-identifier hs-type">InputFieldInfo</span></a></span><span> </span><span id="local-6989586621689361614"><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361614"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span id="local-6989586621689361613"><span class="annot"><span class="annottext">Maybe (Value Void)
</span><a href="#local-6989586621689361613"><span class="hs-identifier hs-var">v1</span></a></span></span><span> </span><span id="local-6989586621689361612"><span class="annot"><span class="annottext">== :: InputFieldInfo origin -&gt; InputFieldInfo origin -&gt; Bool
</span><span class="hs-operator hs-var hs-var hs-var hs-var">==</span></span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputFieldInfo"><span class="hs-identifier hs-type">InputFieldInfo</span></a></span><span> </span><span id="local-6989586621689361611"><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361611"><span class="hs-identifier hs-var">t2</span></a></span></span><span> </span><span id="local-6989586621689361610"><span class="annot"><span class="annottext">Maybe (Value Void)
</span><a href="#local-6989586621689361610"><span class="hs-identifier hs-var">v2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type origin k -&gt; Type origin k -&gt; Bool
forall origin (k1 :: Kind) (k2 :: Kind).
Type origin k1 -&gt; Type origin k2 -&gt; Bool
</span><a href="Hasura.GraphQL.Parser.Schema.html#eqType"><span class="hs-identifier hs-var">eqType</span></a></span><span> </span><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361614"><span class="hs-identifier hs-var">t1</span></a></span><span> </span><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361611"><span class="hs-identifier hs-var">t2</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Value Void)
</span><a href="#local-6989586621689361613"><span class="hs-identifier hs-var">v1</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Value Void) -&gt; Maybe (Value Void) -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Value Void)
</span><a href="#local-6989586621689361610"><span class="hs-identifier hs-var">v2</span></a></span></span><span>
</span><span id="line-652"></span><span>
</span><span id="line-653"></span><span class="hs-keyword">data</span><span> </span><span id="FieldInfo"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#FieldInfo"><span class="hs-identifier hs-var">FieldInfo</span></a></span></span><span> </span><span id="local-6989586621689361609"><span class="annot"><a href="#local-6989586621689361609"><span class="hs-identifier hs-type">origin</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621689361608"><span class="annot"><a href="#local-6989586621689361608"><span class="hs-identifier hs-type">k</span></a></span></span><span class="hs-operator">.</span><span>
</span><span id="line-654"></span><span>  </span><span class="hs-special">(</span><span class="hs-special">'</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Output"><span class="hs-identifier hs-type">Output</span></a></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#%3C%3A"><span class="hs-operator hs-type">&lt;:</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361608"><span class="hs-identifier hs-type">k</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-655"></span><span>  </span><span id="FieldInfo"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#FieldInfo"><span class="hs-identifier hs-var">FieldInfo</span></a></span></span><span>
</span><span id="line-656"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="fArguments"><span class="annot"><span class="annottext">FieldInfo origin -&gt; [Definition origin (InputFieldInfo origin)]
</span><a href="Hasura.GraphQL.Parser.Schema.html#fArguments"><span class="hs-identifier hs-var hs-var">fArguments</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361609"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputFieldInfo"><span class="hs-identifier hs-type">InputFieldInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361609"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-657"></span><span>    </span><span id="fType"><span class="annot"><span class="annottext">()
</span><a href="Hasura.GraphQL.Parser.Schema.html#fType"><span class="hs-identifier hs-var hs-var">fType</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361609"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361608"><span class="hs-identifier hs-type">k</span></a></span><span>
</span><span id="line-658"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-659"></span><span>
</span><span id="line-660"></span><span id="local-6989586621689361604"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621689361601"><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#FieldInfo"><span class="hs-identifier hs-type">FieldInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361604"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-661"></span><span>  </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#FieldInfo"><span class="hs-identifier hs-type">FieldInfo</span></a></span><span> </span><span id="local-6989586621689361600"><span class="annot"><span class="annottext">[Definition origin (InputFieldInfo origin)]
</span><a href="#local-6989586621689361600"><span class="hs-identifier hs-var">args1</span></a></span></span><span> </span><span id="local-6989586621689361599"><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361599"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span id="local-6989586621689361598"><span class="annot"><span class="annottext">== :: FieldInfo origin -&gt; FieldInfo origin -&gt; Bool
</span><span class="hs-operator hs-var hs-var hs-var hs-var">==</span></span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#FieldInfo"><span class="hs-identifier hs-type">FieldInfo</span></a></span><span> </span><span id="local-6989586621689361597"><span class="annot"><span class="annottext">[Definition origin (InputFieldInfo origin)]
</span><a href="#local-6989586621689361597"><span class="hs-identifier hs-var">args2</span></a></span></span><span> </span><span id="local-6989586621689361596"><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361596"><span class="hs-identifier hs-var">t2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Definition origin (InputFieldInfo origin)]
</span><a href="#local-6989586621689361600"><span class="hs-identifier hs-var">args1</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (InputFieldInfo origin)]
-&gt; [Definition origin (InputFieldInfo origin)] -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">[Definition origin (InputFieldInfo origin)]
</span><a href="#local-6989586621689361597"><span class="hs-identifier hs-var">args2</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Type origin k -&gt; Type origin k -&gt; Bool
forall origin (k1 :: Kind) (k2 :: Kind).
Type origin k1 -&gt; Type origin k2 -&gt; Bool
</span><a href="Hasura.GraphQL.Parser.Schema.html#eqType"><span class="hs-identifier hs-var">eqType</span></a></span><span> </span><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361599"><span class="hs-identifier hs-var">t1</span></a></span><span> </span><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361596"><span class="hs-identifier hs-var">t2</span></a></span></span><span>
</span><span id="line-662"></span><span>
</span><span id="line-663"></span><span class="hs-comment">-- -----------------------------------------------------------------------------</span><span>
</span><span id="line-664"></span><span class="hs-comment">-- support for introspection queries</span><span>
</span><span id="line-665"></span><span>
</span><span id="line-666"></span><span class="hs-comment">-- | This type represents the directives information to be served over GraphQL introspection</span><span>
</span><span id="line-667"></span><span class="hs-keyword">data</span><span> </span><span id="DirectiveInfo"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#DirectiveInfo"><span class="hs-identifier hs-var">DirectiveInfo</span></a></span></span><span> </span><span id="local-6989586621689361595"><span class="annot"><a href="#local-6989586621689361595"><span class="hs-identifier hs-type">origin</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DirectiveInfo"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#DirectiveInfo"><span class="hs-identifier hs-var">DirectiveInfo</span></a></span></span><span>
</span><span id="line-668"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="diName"><span class="annot"><span class="annottext">DirectiveInfo origin -&gt; Name
</span><a href="Hasura.GraphQL.Parser.Schema.html#diName"><span class="hs-identifier hs-var hs-var">diName</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span>
</span><span id="line-669"></span><span>    </span><span id="diDescription"><span class="annot"><span class="annottext">DirectiveInfo origin -&gt; Maybe Description
</span><a href="Hasura.GraphQL.Parser.Schema.html#diDescription"><span class="hs-identifier hs-var hs-var">diDescription</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Description</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-670"></span><span>    </span><span id="diArguments"><span class="annot"><span class="annottext">DirectiveInfo origin -&gt; [Definition origin (InputFieldInfo origin)]
</span><a href="Hasura.GraphQL.Parser.Schema.html#diArguments"><span class="hs-identifier hs-var hs-var">diArguments</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">[</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361595"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputFieldInfo"><span class="hs-identifier hs-type">InputFieldInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361595"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-671"></span><span>    </span><span id="diLocations"><span class="annot"><span class="annottext">DirectiveInfo origin -&gt; [DirectiveLocation]
</span><a href="Hasura.GraphQL.Parser.Schema.html#diLocations"><span class="hs-identifier hs-var hs-var">diLocations</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">DirectiveLocation</span></span><span class="hs-special">]</span><span>
</span><span id="line-672"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-673"></span><span>
</span><span id="line-674"></span><span class="hs-comment">-- | This type contains all the information needed to efficiently serve GraphQL</span><span>
</span><span id="line-675"></span><span class="hs-comment">-- introspection queries. It corresponds to the GraphQL @__Schema@ type defined</span><span>
</span><span id="line-676"></span><span class="hs-comment">-- in &lt;&#167; 4.5 Schema Introspection http://spec.graphql.org/June2018/#sec-Introspection&gt;.</span><span>
</span><span id="line-677"></span><span class="hs-comment">-- See also Note [Basics of introspection schema generation].</span><span>
</span><span id="line-678"></span><span class="hs-keyword">data</span><span> </span><span id="Schema"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Schema"><span class="hs-identifier hs-var">Schema</span></a></span></span><span> </span><span id="local-6989586621689361589"><span class="annot"><a href="#local-6989586621689361589"><span class="hs-identifier hs-type">origin</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Schema"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Schema"><span class="hs-identifier hs-var">Schema</span></a></span></span><span>
</span><span id="line-679"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="sDescription"><span class="annot"><span class="annottext">Schema origin -&gt; Maybe Description
</span><a href="Hasura.GraphQL.Parser.Schema.html#sDescription"><span class="hs-identifier hs-var hs-var">sDescription</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Description</span></span><span class="hs-special">,</span><span>
</span><span id="line-680"></span><span>    </span><span id="sTypes"><span class="annot"><span class="annottext">Schema origin -&gt; HashMap Name (SomeDefinitionTypeInfo origin)
</span><a href="Hasura.GraphQL.Parser.Schema.html#sTypes"><span class="hs-identifier hs-var hs-var">sTypes</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">HashMap</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#SomeDefinitionTypeInfo"><span class="hs-identifier hs-type">SomeDefinitionTypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361589"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-681"></span><span>    </span><span id="sQueryType"><span class="annot"><span class="annottext">Schema origin -&gt; Type origin 'Output
</span><a href="Hasura.GraphQL.Parser.Schema.html#sQueryType"><span class="hs-identifier hs-var hs-var">sQueryType</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361589"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">'</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Output"><span class="hs-identifier hs-type">Output</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-682"></span><span>    </span><span id="sMutationType"><span class="annot"><span class="annottext">Schema origin -&gt; Maybe (Type origin 'Output)
</span><a href="Hasura.GraphQL.Parser.Schema.html#sMutationType"><span class="hs-identifier hs-var hs-var">sMutationType</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361589"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">'</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Output"><span class="hs-identifier hs-type">Output</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-683"></span><span>    </span><span id="sSubscriptionType"><span class="annot"><span class="annottext">Schema origin -&gt; Maybe (Type origin 'Output)
</span><a href="Hasura.GraphQL.Parser.Schema.html#sSubscriptionType"><span class="hs-identifier hs-var hs-var">sSubscriptionType</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361589"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">'</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Output"><span class="hs-identifier hs-type">Output</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-684"></span><span>    </span><span id="sDirectives"><span class="annot"><span class="annottext">Schema origin -&gt; [DirectiveInfo origin]
</span><a href="Hasura.GraphQL.Parser.Schema.html#sDirectives"><span class="hs-identifier hs-var hs-var">sDirectives</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#DirectiveInfo"><span class="hs-identifier hs-type">DirectiveInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361589"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-685"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-686"></span><span>
</span><span id="line-687"></span><span class="hs-keyword">data</span><span> </span><span id="TypeDefinitionsWrapper"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeDefinitionsWrapper"><span class="hs-identifier hs-var">TypeDefinitionsWrapper</span></a></span></span><span> </span><span id="local-6989586621689361581"><span class="annot"><a href="#local-6989586621689361581"><span class="hs-identifier hs-type">origin</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-688"></span><span>  </span><span id="local-6989586621689361579"><span id="local-6989586621689361580"><span id="TypeDefinitionsWrapper"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeDefinitionsWrapper"><span class="hs-identifier hs-var">TypeDefinitionsWrapper</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#HasTypeDefinitions"><span class="hs-identifier hs-type">HasTypeDefinitions</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361580"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361579"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621689361579"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeDefinitionsWrapper"><span class="hs-identifier hs-type">TypeDefinitionsWrapper</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361580"><span class="hs-identifier hs-type">origin</span></a></span></span></span><span>
</span><span id="line-689"></span><span>
</span><span id="line-690"></span><span class="hs-comment">{-
Note [Collecting types from the GraphQL schema]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
A `Parser` object consists of two things:

- a function that is used to process (part of) an incoming query, and
- a piece of GraphQL type information.

The main reason that the GraphQL type information is included is so that we can
generate responses for the introspection fields `__type` and `__schema`.  In
particular, this requires us to have a complete list of all types being used in
our schema.

When we build our schema, we therefore finish by making a full walk over the
entirety of the schema, collecting the GraphQL types encountered in a `HashMap`,
allowing us to look up GraphQL types by name.  At this point we might figure out
that a single name is used to represent two GraphQL types that are materially
distinct.  For instance, the name `author` might be used as both a GraphQL
object, representing a database table, and as a scalar, e.g. as a string name.
It also prevents us from having both

```
type author {
  id : int
  name : string
}
```

and

```
type author {
  id : int
  name : string
  email : string
}
```

in the schema, as the latter has an additional field and is thus distinct from
the former, even though it has the same name.

In fact, for HGE internally, such name clashes are not problematic.  We would
merely end up exposing illegal introspection results.  But in order to produce
introspection results, we have to explore the GraphQL schema anyway, to collect
all types.  We use this opportunity to help our users figure out whether there
are any name clashes, and if so what caused them.  So we do some work to track
where in the schema various GraphQL type names were encountered.  This type
collision information is stored in `ConflictingDefinitions`.

A typical way in which conflicting type definitions occur in practice is if one
version of HGE adds a different version of HGE as a remote schema, particularly
when support for database features was added in the meantime.  For instance, if
we'd add a new operator to boolean expressions, e.g. `XOR`, then this would end
up adding an additional field to every `&lt;column&gt;_bool_exp` object in our schema,
which clashes with the old `&lt;column&gt;_bool_exp` that's part of the remote schema.
This is not a bug of the &quot;conflicting type definitions&quot; logic but a limitation
of the design of HGE, which would be resolved by e.g. having namespaces for
different data sources.
-}</span><span>
</span><span id="line-749"></span><span>
</span><span id="line-750"></span><span class="hs-comment">-- | Recursively collects all type definitions accessible from the given value,</span><span>
</span><span id="line-751"></span><span class="hs-comment">-- attempting to detect any conflicting defintions that may have made it this</span><span>
</span><span id="line-752"></span><span class="hs-comment">-- far (See 'ConflictingDefinitions' for details).</span><span>
</span><span id="line-753"></span><span id="local-6989586621689361576"><span id="local-6989586621689361577"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#collectTypeDefinitions"><span class="hs-identifier hs-type">collectTypeDefinitions</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-754"></span><span>  </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#HasTypeDefinitions"><span class="hs-identifier hs-type">HasTypeDefinitions</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361577"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361576"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-755"></span><span>  </span><span class="annot"><a href="#local-6989586621689361576"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-756"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ConflictingDefinitions"><span class="hs-identifier hs-type">ConflictingDefinitions</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361577"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">HashMap</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#SomeDefinitionTypeInfo"><span class="hs-identifier hs-type">SomeDefinitionTypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361577"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-757"></span><span id="collectTypeDefinitions"><span class="annot"><span class="annottext">collectTypeDefinitions :: a
-&gt; Either
     (ConflictingDefinitions origin)
     (HashMap Name (SomeDefinitionTypeInfo origin))
</span><a href="Hasura.GraphQL.Parser.Schema.html#collectTypeDefinitions"><span class="hs-identifier hs-var hs-var">collectTypeDefinitions</span></a></span></span><span> </span><span id="local-6989586621689361575"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621689361575"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-758"></span><span>  </span><span class="annot"><span class="annottext">(HashMap
   Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
 -&gt; HashMap Name (SomeDefinitionTypeInfo origin))
-&gt; Either
     (ConflictingDefinitions origin)
     (HashMap
        Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
-&gt; Either
     (ConflictingDefinitions origin)
     (HashMap Name (SomeDefinitionTypeInfo origin))
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">((SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
 -&gt; SomeDefinitionTypeInfo origin)
-&gt; HashMap
     Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
-&gt; HashMap Name (SomeDefinitionTypeInfo origin)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">(SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
-&gt; SomeDefinitionTypeInfo origin
forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Either
   (ConflictingDefinitions origin)
   (HashMap
      Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
 -&gt; Either
      (ConflictingDefinitions origin)
      (HashMap Name (SomeDefinitionTypeInfo origin)))
-&gt; Either
     (ConflictingDefinitions origin)
     (HashMap
        Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
-&gt; Either
     (ConflictingDefinitions origin)
     (HashMap Name (SomeDefinitionTypeInfo origin))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-759"></span><span>    </span><span class="annot"><span class="annottext">Except
  (ConflictingDefinitions origin)
  (HashMap
     Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
-&gt; Either
     (ConflictingDefinitions origin)
     (HashMap
        Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
forall e a. Except e a -&gt; Either e a
</span><span class="hs-identifier hs-var">runExcept</span></span><span> </span><span class="annot"><span class="annottext">(Except
   (ConflictingDefinitions origin)
   (HashMap
      Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
 -&gt; Either
      (ConflictingDefinitions origin)
      (HashMap
         Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)))
-&gt; Except
     (ConflictingDefinitions origin)
     (HashMap
        Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
-&gt; Either
     (ConflictingDefinitions origin)
     (HashMap
        Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-760"></span><span>      </span><span class="annot"><span class="annottext">(StateT
   (HashMap
      Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
   (ExceptT (ConflictingDefinitions origin) Identity)
   ()
 -&gt; HashMap
      Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
 -&gt; Except
      (ConflictingDefinitions origin)
      (HashMap
         Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)))
-&gt; HashMap
     Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
-&gt; StateT
     (HashMap
        Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
     (ExceptT (ConflictingDefinitions origin) Identity)
     ()
-&gt; Except
     (ConflictingDefinitions origin)
     (HashMap
        Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">StateT
  (HashMap
     Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
  (ExceptT (ConflictingDefinitions origin) Identity)
  ()
-&gt; HashMap
     Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
-&gt; Except
     (ConflictingDefinitions origin)
     (HashMap
        Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
forall (m :: * -&gt; *) s a. Monad m =&gt; StateT s m a -&gt; s -&gt; m s
</span><span class="hs-identifier hs-var">execStateT</span></span><span> </span><span class="annot"><span class="annottext">HashMap
  Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
forall k v. HashMap k v
</span><span class="hs-identifier hs-var">Map.empty</span></span><span> </span><span class="annot"><span class="annottext">(StateT
   (HashMap
      Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
   (ExceptT (ConflictingDefinitions origin) Identity)
   ()
 -&gt; Except
      (ConflictingDefinitions origin)
      (HashMap
         Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)))
-&gt; StateT
     (HashMap
        Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
     (ExceptT (ConflictingDefinitions origin) Identity)
     ()
-&gt; Except
     (ConflictingDefinitions origin)
     (HashMap
        Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-761"></span><span>        </span><span class="annot"><span class="annottext">(ReaderT
   TypeOriginStack
   (StateT
      (HashMap
         Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
      (ExceptT (ConflictingDefinitions origin) Identity))
   ()
 -&gt; TypeOriginStack
 -&gt; StateT
      (HashMap
         Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
      (ExceptT (ConflictingDefinitions origin) Identity)
      ())
-&gt; TypeOriginStack
-&gt; ReaderT
     TypeOriginStack
     (StateT
        (HashMap
           Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
        (ExceptT (ConflictingDefinitions origin) Identity))
     ()
-&gt; StateT
     (HashMap
        Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
     (ExceptT (ConflictingDefinitions origin) Identity)
     ()
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">ReaderT
  TypeOriginStack
  (StateT
     (HashMap
        Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
     (ExceptT (ConflictingDefinitions origin) Identity))
  ()
-&gt; TypeOriginStack
-&gt; StateT
     (HashMap
        Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
     (ExceptT (ConflictingDefinitions origin) Identity)
     ()
forall r (m :: * -&gt; *) a. ReaderT r m a -&gt; r -&gt; m a
</span><span class="hs-identifier hs-var hs-var">runReaderT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Name] -&gt; TypeOriginStack
</span><a href="Hasura.GraphQL.Parser.Schema.html#TypeOriginStack"><span class="hs-identifier hs-var">TypeOriginStack</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(ReaderT
   TypeOriginStack
   (StateT
      (HashMap
         Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
      (ExceptT (ConflictingDefinitions origin) Identity))
   ()
 -&gt; StateT
      (HashMap
         Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
      (ExceptT (ConflictingDefinitions origin) Identity)
      ())
-&gt; ReaderT
     TypeOriginStack
     (StateT
        (HashMap
           Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
        (ExceptT (ConflictingDefinitions origin) Identity))
     ()
-&gt; StateT
     (HashMap
        Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
     (ExceptT (ConflictingDefinitions origin) Identity)
     ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-762"></span><span>          </span><span class="annot"><span class="annottext">TypeAccumulation origin ()
-&gt; ReaderT
     TypeOriginStack
     (StateT
        (HashMap
           Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
        (ExceptT (ConflictingDefinitions origin) Identity))
     ()
forall origin a.
TypeAccumulation origin a
-&gt; ReaderT
     TypeOriginStack
     (StateT
        (HashMap
           Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
        (ExceptT (ConflictingDefinitions origin) Identity))
     a
</span><a href="Hasura.GraphQL.Parser.Schema.html#runTypeAccumulation"><span class="hs-identifier hs-var hs-var">runTypeAccumulation</span></a></span><span> </span><span class="annot"><span class="annottext">(TypeAccumulation origin ()
 -&gt; ReaderT
      TypeOriginStack
      (StateT
         (HashMap
            Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
         (ExceptT (ConflictingDefinitions origin) Identity))
      ())
-&gt; TypeAccumulation origin ()
-&gt; ReaderT
     TypeOriginStack
     (StateT
        (HashMap
           Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
        (ExceptT (ConflictingDefinitions origin) Identity))
     ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-763"></span><span>            </span><span class="annot"><span class="annottext">a -&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621689361575"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-764"></span><span>
</span><span id="line-765"></span><span class="hs-comment">-- | A path through 'Definition', accumulated in 'accumulateTypeDefinitions'</span><span>
</span><span id="line-766"></span><span class="hs-comment">-- only to power 'ConflictingDefinitions' in the error case.</span><span>
</span><span id="line-767"></span><span class="hs-keyword">newtype</span><span> </span><span id="TypeOriginStack"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeOriginStack"><span class="hs-identifier hs-var">TypeOriginStack</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="TypeOriginStack"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeOriginStack"><span class="hs-identifier hs-var">TypeOriginStack</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>
</span><span id="line-768"></span><span>
</span><span id="line-769"></span><span class="hs-comment">-- Add the current field name to the origin stack</span><span>
</span><span id="line-770"></span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#typeOriginRecurse"><span class="hs-identifier hs-type">typeOriginRecurse</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeOriginStack"><span class="hs-identifier hs-type">TypeOriginStack</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeOriginStack"><span class="hs-identifier hs-type">TypeOriginStack</span></a></span><span>
</span><span id="line-771"></span><span id="typeOriginRecurse"><span class="annot"><span class="annottext">typeOriginRecurse :: Name -&gt; TypeOriginStack -&gt; TypeOriginStack
</span><a href="Hasura.GraphQL.Parser.Schema.html#typeOriginRecurse"><span class="hs-identifier hs-var hs-var">typeOriginRecurse</span></a></span></span><span> </span><span id="local-6989586621689361567"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361567"><span class="hs-identifier hs-var">field</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeOriginStack"><span class="hs-identifier hs-type">TypeOriginStack</span></a></span><span> </span><span id="local-6989586621689361566"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621689361566"><span class="hs-identifier hs-var">origins</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; TypeOriginStack
</span><a href="Hasura.GraphQL.Parser.Schema.html#TypeOriginStack"><span class="hs-identifier hs-var">TypeOriginStack</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361567"><span class="hs-identifier hs-var">field</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; [Name]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621689361566"><span class="hs-identifier hs-var">origins</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-772"></span><span>
</span><span id="line-773"></span><span class="hs-comment">-- This is kind of a hack to make sure that the query root name is part of the origin stack</span><span>
</span><span id="line-774"></span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#typeRootRecurse"><span class="hs-identifier hs-type">typeRootRecurse</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeOriginStack"><span class="hs-identifier hs-type">TypeOriginStack</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeOriginStack"><span class="hs-identifier hs-type">TypeOriginStack</span></a></span><span>
</span><span id="line-775"></span><span id="typeRootRecurse"><span class="annot"><span class="annottext">typeRootRecurse :: Name -&gt; TypeOriginStack -&gt; TypeOriginStack
</span><a href="Hasura.GraphQL.Parser.Schema.html#typeRootRecurse"><span class="hs-identifier hs-var hs-var">typeRootRecurse</span></a></span></span><span> </span><span id="local-6989586621689361564"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361564"><span class="hs-identifier hs-var">rootName</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeOriginStack"><span class="hs-identifier hs-type">TypeOriginStack</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Name] -&gt; TypeOriginStack
</span><a href="Hasura.GraphQL.Parser.Schema.html#TypeOriginStack"><span class="hs-identifier hs-var">TypeOriginStack</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361564"><span class="hs-identifier hs-var">rootName</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-776"></span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#typeRootRecurse"><span class="hs-identifier hs-var">typeRootRecurse</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621689361563"><span class="annot"><span class="annottext">TypeOriginStack
</span><a href="#local-6989586621689361563"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TypeOriginStack
</span><a href="#local-6989586621689361563"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-777"></span><span>
</span><span id="line-778"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="../file:///workdir/dist-newstyle/build/x86_64-linux/ghc-8.10.7/hasura-error-message-1.0.0/opt/doc/html/hasura-error-message/src"><span class="hs-identifier hs-type">ToErrorValue</span></a></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeOriginStack"><span class="hs-identifier hs-type">TypeOriginStack</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-779"></span><span>  </span><span id="local-6989586621689361560"><span class="annot"><span class="annottext">toErrorValue :: TypeOriginStack -&gt; ErrorMessage
</span><a href="../file:///workdir/dist-newstyle/build/x86_64-linux/ghc-8.10.7/hasura-error-message-1.0.0/opt/doc/html/hasura-error-message/src"><span class="hs-identifier hs-var hs-var hs-var hs-var">toErrorValue</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeOriginStack"><span class="hs-identifier hs-type">TypeOriginStack</span></a></span><span> </span><span id="local-6989586621689361558"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621689361558"><span class="hs-identifier hs-var">fields</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Text -&gt; ErrorMessage
</span><a href="../file:///workdir/dist-newstyle/build/x86_64-linux/ghc-8.10.7/hasura-error-message-1.0.0/opt/doc/html/hasura-error-message/src"><span class="hs-identifier hs-var">toErrorMessage</span></a></span><span> </span><span class="annot"><span class="annottext">(Text -&gt; ErrorMessage)
-&gt; ([Name] -&gt; Text) -&gt; [Name] -&gt; ErrorMessage
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Text -&gt; [Text] -&gt; Text
</span><span class="hs-identifier hs-var">T.intercalate</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;.&quot;</span></span><span> </span><span class="annot"><span class="annottext">([Text] -&gt; Text) -&gt; ([Name] -&gt; [Text]) -&gt; [Name] -&gt; Text
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Text) -&gt; [Name] -&gt; [Text]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Text
</span><span class="hs-identifier hs-var hs-var">unName</span></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; [Text]) -&gt; ([Name] -&gt; [Name]) -&gt; [Name] -&gt; [Text]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name]
forall a. [a] -&gt; [a]
</span><span class="hs-identifier hs-var">reverse</span></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; ErrorMessage) -&gt; [Name] -&gt; ErrorMessage
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621689361558"><span class="hs-identifier hs-var">fields</span></a></span><span>
</span><span id="line-780"></span><span>
</span><span id="line-781"></span><span class="hs-comment">-- | NOTE: it's not clear exactly where we'd get conflicting definitions at the</span><span>
</span><span id="line-782"></span><span class="hs-comment">-- point 'collectTypeDefinitions' is called, but conflicting names from</span><span>
</span><span id="line-783"></span><span class="hs-comment">-- different data sources is apparently one place (TODO some tests that</span><span>
</span><span id="line-784"></span><span class="hs-comment">-- excercise this).</span><span>
</span><span id="line-785"></span><span class="hs-comment">--</span><span>
</span><span id="line-786"></span><span class="hs-comment">-- ALSO NOTE: it's difficult to see in isolation how or if this check is</span><span>
</span><span id="line-787"></span><span class="hs-comment">-- correct since 'Definition' is cyclic and has no accomodations for observable</span><span>
</span><span id="line-788"></span><span class="hs-comment">-- sharing (formerly it had Uniques; see commit history and discussion in</span><span>
</span><span id="line-789"></span><span class="hs-comment">-- #3685). The check relies on dodgy Eq instances for the types that make up</span><span>
</span><span id="line-790"></span><span class="hs-comment">-- the Definition graph (see e.g. @instance Eq ObjectInfo@).</span><span>
</span><span id="line-791"></span><span class="hs-comment">--</span><span>
</span><span id="line-792"></span><span class="hs-comment">-- See Note [Collecting types from the GraphQL schema]</span><span>
</span><span id="line-793"></span><span class="hs-keyword">data</span><span> </span><span id="ConflictingDefinitions"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ConflictingDefinitions"><span class="hs-identifier hs-var">ConflictingDefinitions</span></a></span></span><span> </span><span id="local-6989586621689361972"><span class="annot"><a href="#local-6989586621689361972"><span class="hs-identifier hs-type">origin</span></a></span></span><span>
</span><span id="line-794"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- | Type collection has found at least two types with the same name.</span><span>
</span><span id="line-795"></span><span>    </span><span id="ConflictingDefinitions"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ConflictingDefinitions"><span class="hs-identifier hs-var">ConflictingDefinitions</span></a></span></span><span>
</span><span id="line-796"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#SomeDefinitionTypeInfo"><span class="hs-identifier hs-type">SomeDefinitionTypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361972"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeOriginStack"><span class="hs-identifier hs-type">TypeOriginStack</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-797"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#SomeDefinitionTypeInfo"><span class="hs-identifier hs-type">SomeDefinitionTypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361972"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NonEmpty</span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeOriginStack"><span class="hs-identifier hs-type">TypeOriginStack</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-798"></span><span>
</span><span id="line-799"></span><span class="hs-comment">-- | Although the majority of graphql-engine is written in terms of abstract</span><span>
</span><span id="line-800"></span><span class="hs-comment">-- mtl-style effect monads, we figured out that this particular codepath is</span><span>
</span><span id="line-801"></span><span class="hs-comment">-- quite hot, and that mtl has a measurable negative effect for accumulating</span><span>
</span><span id="line-802"></span><span class="hs-comment">-- types from the schema, both in profiling and in benchmarking.  Using an</span><span>
</span><span id="line-803"></span><span class="hs-comment">-- explicit transformers-style effect stack seems to overall memory usage by</span><span>
</span><span id="line-804"></span><span class="hs-comment">-- about 3-7%.</span><span>
</span><span id="line-805"></span><span class="hs-keyword">newtype</span><span> </span><span id="TypeAccumulation"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeAccumulation"><span class="hs-identifier hs-var">TypeAccumulation</span></a></span></span><span> </span><span id="local-6989586621689362059"><span class="annot"><a href="#local-6989586621689362059"><span class="hs-identifier hs-type">origin</span></a></span></span><span> </span><span id="local-6989586621689362058"><span class="annot"><a href="#local-6989586621689362058"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="TypeAccumulation"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeAccumulation"><span class="hs-identifier hs-var">TypeAccumulation</span></a></span></span><span>
</span><span id="line-806"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="runTypeAccumulation"><span class="annot"><span class="annottext">TypeAccumulation origin a
-&gt; ReaderT
     TypeOriginStack
     (StateT
        (HashMap
           Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
        (ExceptT (ConflictingDefinitions origin) Identity))
     a
</span><a href="Hasura.GraphQL.Parser.Schema.html#runTypeAccumulation"><span class="hs-identifier hs-var hs-var">runTypeAccumulation</span></a></span></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-807"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">ReaderT</span></span><span>
</span><span id="line-808"></span><span>        </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeOriginStack"><span class="hs-identifier hs-type">TypeOriginStack</span></a></span><span>
</span><span id="line-809"></span><span>        </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier hs-type">StateT</span></span><span>
</span><span id="line-810"></span><span>            </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">HashMap</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#SomeDefinitionTypeInfo"><span class="hs-identifier hs-type">SomeDefinitionTypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362059"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NonEmpty</span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeOriginStack"><span class="hs-identifier hs-type">TypeOriginStack</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-811"></span><span>            </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ExceptT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ConflictingDefinitions"><span class="hs-identifier hs-type">ConflictingDefinitions</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362059"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Identity</span></span><span class="hs-special">)</span><span>
</span><span id="line-812"></span><span>        </span><span class="hs-special">)</span><span>
</span><span id="line-813"></span><span>        </span><span class="annot"><a href="#local-6989586621689362058"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-814"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-815"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621689361548"><span id="local-6989586621689361550"><span class="annot"><span class="annottext">a -&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin a
(a -&gt; b) -&gt; TypeAccumulation origin a -&gt; TypeAccumulation origin b
(forall a b.
 (a -&gt; b) -&gt; TypeAccumulation origin a -&gt; TypeAccumulation origin b)
-&gt; (forall a b.
    a -&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin a)
-&gt; Functor (TypeAccumulation origin)
forall a b.
a -&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin a
forall a b.
(a -&gt; b) -&gt; TypeAccumulation origin a -&gt; TypeAccumulation origin b
forall origin a b.
a -&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin a
forall origin a b.
(a -&gt; b) -&gt; TypeAccumulation origin a -&gt; TypeAccumulation origin b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: a -&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin a
$c&lt;$ :: forall origin a b.
a -&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin a
fmap :: (a -&gt; b) -&gt; TypeAccumulation origin a -&gt; TypeAccumulation origin b
$cfmap :: forall origin a b.
(a -&gt; b) -&gt; TypeAccumulation origin a -&gt; TypeAccumulation origin b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621689361537"><span id="local-6989586621689361539"><span id="local-6989586621689361541"><span id="local-6989586621689361543"><span id="local-6989586621689361545"><span class="annot"><span class="annottext">Functor (TypeAccumulation origin)
a -&gt; TypeAccumulation origin a
Functor (TypeAccumulation origin)
-&gt; (forall a. a -&gt; TypeAccumulation origin a)
-&gt; (forall a b.
    TypeAccumulation origin (a -&gt; b)
    -&gt; TypeAccumulation origin a -&gt; TypeAccumulation origin b)
-&gt; (forall a b c.
    (a -&gt; b -&gt; c)
    -&gt; TypeAccumulation origin a
    -&gt; TypeAccumulation origin b
    -&gt; TypeAccumulation origin c)
-&gt; (forall a b.
    TypeAccumulation origin a
    -&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin b)
-&gt; (forall a b.
    TypeAccumulation origin a
    -&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin a)
-&gt; Applicative (TypeAccumulation origin)
TypeAccumulation origin a
-&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin b
TypeAccumulation origin a
-&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin a
TypeAccumulation origin (a -&gt; b)
-&gt; TypeAccumulation origin a -&gt; TypeAccumulation origin b
(a -&gt; b -&gt; c)
-&gt; TypeAccumulation origin a
-&gt; TypeAccumulation origin b
-&gt; TypeAccumulation origin c
forall origin. Functor (TypeAccumulation origin)
forall a. a -&gt; TypeAccumulation origin a
forall origin a. a -&gt; TypeAccumulation origin a
forall a b.
TypeAccumulation origin a
-&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin a
forall a b.
TypeAccumulation origin a
-&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin b
forall a b.
TypeAccumulation origin (a -&gt; b)
-&gt; TypeAccumulation origin a -&gt; TypeAccumulation origin b
forall origin a b.
TypeAccumulation origin a
-&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin a
forall origin a b.
TypeAccumulation origin a
-&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin b
forall origin a b.
TypeAccumulation origin (a -&gt; b)
-&gt; TypeAccumulation origin a -&gt; TypeAccumulation origin b
forall a b c.
(a -&gt; b -&gt; c)
-&gt; TypeAccumulation origin a
-&gt; TypeAccumulation origin b
-&gt; TypeAccumulation origin c
forall origin a b c.
(a -&gt; b -&gt; c)
-&gt; TypeAccumulation origin a
-&gt; TypeAccumulation origin b
-&gt; TypeAccumulation origin c
forall (f :: * -&gt; *).
Functor f
-&gt; (forall a. a -&gt; f a)
-&gt; (forall a b. f (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b c. (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c)
-&gt; (forall a b. f a -&gt; f b -&gt; f b)
-&gt; (forall a b. f a -&gt; f b -&gt; f a)
-&gt; Applicative f
&lt;* :: TypeAccumulation origin a
-&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin a
$c&lt;* :: forall origin a b.
TypeAccumulation origin a
-&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin a
*&gt; :: TypeAccumulation origin a
-&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin b
$c*&gt; :: forall origin a b.
TypeAccumulation origin a
-&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin b
liftA2 :: (a -&gt; b -&gt; c)
-&gt; TypeAccumulation origin a
-&gt; TypeAccumulation origin b
-&gt; TypeAccumulation origin c
$cliftA2 :: forall origin a b c.
(a -&gt; b -&gt; c)
-&gt; TypeAccumulation origin a
-&gt; TypeAccumulation origin b
-&gt; TypeAccumulation origin c
&lt;*&gt; :: TypeAccumulation origin (a -&gt; b)
-&gt; TypeAccumulation origin a -&gt; TypeAccumulation origin b
$c&lt;*&gt; :: forall origin a b.
TypeAccumulation origin (a -&gt; b)
-&gt; TypeAccumulation origin a -&gt; TypeAccumulation origin b
pure :: a -&gt; TypeAccumulation origin a
$cpure :: forall origin a. a -&gt; TypeAccumulation origin a
$cp1Applicative :: forall origin. Functor (TypeAccumulation origin)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Applicative</span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621689361529"><span id="local-6989586621689361531"><span id="local-6989586621689361533"><span class="annot"><span class="annottext">Applicative (TypeAccumulation origin)
a -&gt; TypeAccumulation origin a
Applicative (TypeAccumulation origin)
-&gt; (forall a b.
    TypeAccumulation origin a
    -&gt; (a -&gt; TypeAccumulation origin b) -&gt; TypeAccumulation origin b)
-&gt; (forall a b.
    TypeAccumulation origin a
    -&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin b)
-&gt; (forall a. a -&gt; TypeAccumulation origin a)
-&gt; Monad (TypeAccumulation origin)
TypeAccumulation origin a
-&gt; (a -&gt; TypeAccumulation origin b) -&gt; TypeAccumulation origin b
TypeAccumulation origin a
-&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin b
forall origin. Applicative (TypeAccumulation origin)
forall a. a -&gt; TypeAccumulation origin a
forall origin a. a -&gt; TypeAccumulation origin a
forall a b.
TypeAccumulation origin a
-&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin b
forall a b.
TypeAccumulation origin a
-&gt; (a -&gt; TypeAccumulation origin b) -&gt; TypeAccumulation origin b
forall origin a b.
TypeAccumulation origin a
-&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin b
forall origin a b.
TypeAccumulation origin a
-&gt; (a -&gt; TypeAccumulation origin b) -&gt; TypeAccumulation origin b
forall (m :: * -&gt; *).
Applicative m
-&gt; (forall a b. m a -&gt; (a -&gt; m b) -&gt; m b)
-&gt; (forall a b. m a -&gt; m b -&gt; m b)
-&gt; (forall a. a -&gt; m a)
-&gt; Monad m
return :: a -&gt; TypeAccumulation origin a
$creturn :: forall origin a. a -&gt; TypeAccumulation origin a
&gt;&gt; :: TypeAccumulation origin a
-&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin b
$c&gt;&gt; :: forall origin a b.
TypeAccumulation origin a
-&gt; TypeAccumulation origin b -&gt; TypeAccumulation origin b
&gt;&gt;= :: TypeAccumulation origin a
-&gt; (a -&gt; TypeAccumulation origin b) -&gt; TypeAccumulation origin b
$c&gt;&gt;= :: forall origin a b.
TypeAccumulation origin a
-&gt; (a -&gt; TypeAccumulation origin b) -&gt; TypeAccumulation origin b
$cp1Monad :: forall origin. Applicative (TypeAccumulation origin)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Monad</span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-816"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621689361521"><span id="local-6989586621689361523"><span id="local-6989586621689361525"><span class="annot"><span class="hs-identifier hs-type">MonadReader</span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeOriginStack"><span class="hs-identifier hs-type">TypeOriginStack</span></a></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-817"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621689361513"><span id="local-6989586621689361515"><span id="local-6989586621689361517"><span class="annot"><span class="hs-identifier hs-type">MonadState</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">HashMap</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#SomeDefinitionTypeInfo"><span class="hs-identifier hs-type">SomeDefinitionTypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362059"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NonEmpty</span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeOriginStack"><span class="hs-identifier hs-type">TypeOriginStack</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-818"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621689361507"><span id="local-6989586621689361509"><span class="annot"><span class="hs-identifier hs-type">MonadError</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ConflictingDefinitions"><span class="hs-identifier hs-type">ConflictingDefinitions</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362059"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span></span></span><span class="hs-special">)</span><span>
</span><span id="line-819"></span><span>
</span><span id="line-820"></span><span class="hs-keyword">class</span><span> </span><span id="HasTypeDefinitions"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#HasTypeDefinitions"><span class="hs-identifier hs-var">HasTypeDefinitions</span></a></span></span><span> </span><span id="local-6989586621689362057"><span class="annot"><a href="#local-6989586621689362057"><span class="hs-identifier hs-type">origin</span></a></span></span><span> </span><span id="local-6989586621689362056"><span class="annot"><a href="#local-6989586621689362056"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-821"></span><span>  </span><span class="hs-comment">-- | Recursively accumulates all type definitions accessible from the given</span><span>
</span><span id="line-822"></span><span>  </span><span class="hs-comment">-- value. This is done statefully to avoid infinite loops arising from</span><span>
</span><span id="line-823"></span><span>  </span><span class="hs-comment">-- recursive type definitions; see Note [Tying the knot] in Hasura.GraphQL.Parser.Class.</span><span>
</span><span id="line-824"></span><span>  </span><span id="accumulateTypeDefinitions"><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-type">accumulateTypeDefinitions</span></a></span></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-825"></span><span>    </span><span class="annot"><a href="#local-6989586621689362056"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeAccumulation"><span class="hs-identifier hs-type">TypeAccumulation</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689362057"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-826"></span><span>
</span><span id="line-827"></span><span id="local-6989586621689361504"><span id="local-6989586621689361505"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#HasTypeDefinitions"><span class="hs-identifier hs-type">HasTypeDefinitions</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361505"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361505"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeInfo"><span class="hs-identifier hs-type">TypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361505"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361504"><span class="hs-identifier hs-type">k</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-828"></span><span>  </span><span id="local-6989586621689361501"><span class="annot"><span class="annottext">accumulateTypeDefinitions :: Definition origin (TypeInfo origin k) -&gt; TypeAccumulation origin ()
</span><a href="#local-6989586621689361501"><span class="hs-identifier hs-var hs-var hs-var hs-var">accumulateTypeDefinitions</span></a></span></span><span> </span><span id="local-6989586621689361500"><span class="annot"><span class="annottext">new :: Definition origin (TypeInfo origin k)
</span><a href="#local-6989586621689361500"><span class="hs-identifier hs-var">new</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="hs-special">{</span><span id="local-6989586621689361495"><span id="local-6989586621689361496"><span id="local-6989586621689361497"><span id="local-6989586621689361498"><span id="local-6989586621689361499"><span class="annot"><span class="annottext">[Directive Void]
Maybe origin
Maybe Description
Name
TypeInfo origin k
dInfo :: TypeInfo origin k
dDirectives :: [Directive Void]
dOrigin :: Maybe origin
dDescription :: Maybe Description
dName :: Name
dDirectives :: forall origin a. Definition origin a -&gt; [Directive Void]
dOrigin :: forall origin a. Definition origin a -&gt; Maybe origin
dDescription :: forall origin a. Definition origin a -&gt; Maybe Description
dInfo :: forall origin a. Definition origin a -&gt; a
dName :: forall origin a. Definition origin a -&gt; Name
</span><a href="#local-6989586621689361495"><span class="hs-glyph hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">..</span></a></span></span></span></span></span></span><span class="hs-special">}</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-829"></span><span>    </span><span class="hs-comment">-- This is the important case! We actually have a type definition, so we</span><span>
</span><span id="line-830"></span><span>    </span><span class="hs-comment">-- need to add it to the state.</span><span>
</span><span id="line-831"></span><span>    </span><span id="local-6989586621689361494"><span class="annot"><span class="annottext">HashMap
  Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
</span><a href="#local-6989586621689361494"><span class="hs-identifier hs-var">definitions</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TypeAccumulation
  origin
  (HashMap
     Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack))
forall s (m :: * -&gt; *). MonadState s m =&gt; m s
</span><span class="hs-identifier hs-var">get</span></span><span>
</span><span id="line-832"></span><span>    </span><span id="local-6989586621689361492"><span class="annot"><span class="annottext">TypeOriginStack
</span><a href="#local-6989586621689361492"><span class="hs-identifier hs-var">stack</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TypeAccumulation origin TypeOriginStack
forall r (m :: * -&gt; *). MonadReader r m =&gt; m r
</span><span class="hs-identifier hs-var">ask</span></span><span>
</span><span id="line-833"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621689361490"><span class="annot"><span class="annottext">someNew :: SomeDefinitionTypeInfo origin
</span><a href="#local-6989586621689361490"><span class="hs-identifier hs-var hs-var">someNew</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
-&gt; SomeDefinitionTypeInfo origin
forall origin (k :: Kind).
Definition origin (TypeInfo origin k)
-&gt; SomeDefinitionTypeInfo origin
</span><a href="Hasura.GraphQL.Parser.Schema.html#SomeDefinitionTypeInfo"><span class="hs-identifier hs-var">SomeDefinitionTypeInfo</span></a></span><span> </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
</span><a href="#local-6989586621689361500"><span class="hs-identifier hs-var">new</span></a></span><span>
</span><span id="line-834"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Name
-&gt; HashMap
     Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
-&gt; Maybe (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
forall k v. (Eq k, Hashable k) =&gt; k -&gt; HashMap k v -&gt; Maybe v
</span><span class="hs-identifier hs-var">Map.lookup</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361499"><span class="hs-identifier hs-var">dName</span></a></span><span> </span><span class="annot"><span class="annottext">HashMap
  Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
</span><a href="#local-6989586621689361494"><span class="hs-identifier hs-var">definitions</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-835"></span><span>      </span><span class="annot"><span class="annottext">Maybe (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-836"></span><span>        </span><span class="annot"><span class="annottext">HashMap
  Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
-&gt; TypeAccumulation origin ()
forall s (m :: * -&gt; *). MonadState s m =&gt; s -&gt; m ()
</span><span class="hs-identifier hs-var">put</span></span><span> </span><span class="annot"><span class="annottext">(HashMap
   Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
 -&gt; TypeAccumulation origin ())
-&gt; HashMap
     Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
-&gt; TypeAccumulation origin ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$!</span></span><span> </span><span class="annot"><span class="annottext">Name
-&gt; (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
-&gt; HashMap
     Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
-&gt; HashMap
     Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
forall k v.
(Eq k, Hashable k) =&gt;
k -&gt; v -&gt; HashMap k v -&gt; HashMap k v
</span><span class="hs-identifier hs-var">Map.insert</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361499"><span class="hs-identifier hs-var">dName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SomeDefinitionTypeInfo origin
</span><a href="#local-6989586621689361490"><span class="hs-identifier hs-var">someNew</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">TypeOriginStack -&gt; NonEmpty TypeOriginStack
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">TypeOriginStack
</span><a href="#local-6989586621689361492"><span class="hs-identifier hs-var">stack</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">HashMap
  Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
</span><a href="#local-6989586621689361494"><span class="hs-identifier hs-var">definitions</span></a></span><span>
</span><span id="line-837"></span><span>        </span><span class="hs-comment">-- This type definition might reference other type definitions, so we</span><span>
</span><span id="line-838"></span><span>        </span><span class="hs-comment">-- still need to recur.</span><span>
</span><span id="line-839"></span><span>        </span><span class="annot"><span class="annottext">(TypeOriginStack -&gt; TypeOriginStack)
-&gt; TypeAccumulation origin () -&gt; TypeAccumulation origin ()
forall r (m :: * -&gt; *) a. MonadReader r m =&gt; (r -&gt; r) -&gt; m a -&gt; m a
</span><span class="hs-identifier hs-var">local</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; TypeOriginStack -&gt; TypeOriginStack
</span><a href="Hasura.GraphQL.Parser.Schema.html#typeRootRecurse"><span class="hs-identifier hs-var">typeRootRecurse</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361499"><span class="hs-identifier hs-var">dName</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(TypeAccumulation origin () -&gt; TypeAccumulation origin ())
-&gt; TypeAccumulation origin () -&gt; TypeAccumulation origin ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TypeInfo origin k -&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span><span> </span><span class="annot"><span class="annottext">TypeInfo origin k
</span><a href="#local-6989586621689361495"><span class="hs-identifier hs-var">dInfo</span></a></span><span>
</span><span id="line-840"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621689361484"><span class="annot"><span class="annottext">SomeDefinitionTypeInfo origin
</span><a href="#local-6989586621689361484"><span class="hs-identifier hs-var">someOld</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621689361483"><span class="annot"><span class="annottext">NonEmpty TypeOriginStack
</span><a href="#local-6989586621689361483"><span class="hs-identifier hs-var">origins</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-841"></span><span>        </span><span class="hs-comment">-- It&#8217;s important we /don&#8217;t/ recur if we&#8217;ve already seen this definition</span><span>
</span><span id="line-842"></span><span>        </span><span class="hs-comment">-- before to avoid infinite loops; see Note [Tying the knot] in Hasura.GraphQL.Parser.Class.</span><span>
</span><span id="line-843"></span><span>        </span><span class="hs-comment">-- (NOTE: I tried making `origins` an STRef and doing a mutable update</span><span>
</span><span id="line-844"></span><span>        </span><span class="hs-comment">-- here but the performance was about the same)</span><span>
</span><span id="line-845"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">SomeDefinitionTypeInfo origin
</span><a href="#local-6989586621689361484"><span class="hs-identifier hs-var">someOld</span></a></span><span> </span><span class="annot"><span class="annottext">SomeDefinitionTypeInfo origin
-&gt; SomeDefinitionTypeInfo origin -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">SomeDefinitionTypeInfo origin
</span><a href="#local-6989586621689361490"><span class="hs-identifier hs-var">someNew</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">HashMap
  Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
-&gt; TypeAccumulation origin ()
forall s (m :: * -&gt; *). MonadState s m =&gt; s -&gt; m ()
</span><span class="hs-identifier hs-var">put</span></span><span> </span><span class="annot"><span class="annottext">(HashMap
   Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
 -&gt; TypeAccumulation origin ())
-&gt; HashMap
     Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
-&gt; TypeAccumulation origin ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$!</span></span><span> </span><span class="annot"><span class="annottext">Name
-&gt; (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
-&gt; HashMap
     Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
-&gt; HashMap
     Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
forall k v.
(Eq k, Hashable k) =&gt;
k -&gt; v -&gt; HashMap k v -&gt; HashMap k v
</span><span class="hs-identifier hs-var">Map.insert</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361499"><span class="hs-identifier hs-var">dName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SomeDefinitionTypeInfo origin
</span><a href="#local-6989586621689361484"><span class="hs-identifier hs-var">someOld</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">TypeOriginStack
</span><a href="#local-6989586621689361492"><span class="hs-identifier hs-var">stack</span></a></span><span> </span><span class="annot"><span class="annottext">TypeOriginStack
-&gt; NonEmpty TypeOriginStack -&gt; NonEmpty TypeOriginStack
forall a. a -&gt; NonEmpty a -&gt; NonEmpty a
</span><span class="hs-operator hs-var">`NE.cons`</span></span><span> </span><span class="annot"><span class="annottext">NonEmpty TypeOriginStack
</span><a href="#local-6989586621689361483"><span class="hs-identifier hs-var">origins</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">HashMap
  Name (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
</span><a href="#local-6989586621689361494"><span class="hs-identifier hs-var">definitions</span></a></span><span>
</span><span id="line-846"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ConflictingDefinitions origin -&gt; TypeAccumulation origin ()
forall e (m :: * -&gt; *) a. MonadError e m =&gt; e -&gt; m a
</span><span class="hs-identifier hs-var">throwError</span></span><span> </span><span class="annot"><span class="annottext">(ConflictingDefinitions origin -&gt; TypeAccumulation origin ())
-&gt; ConflictingDefinitions origin -&gt; TypeAccumulation origin ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(SomeDefinitionTypeInfo origin, TypeOriginStack)
-&gt; (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
-&gt; ConflictingDefinitions origin
forall origin.
(SomeDefinitionTypeInfo origin, TypeOriginStack)
-&gt; (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack)
-&gt; ConflictingDefinitions origin
</span><a href="Hasura.GraphQL.Parser.Schema.html#ConflictingDefinitions"><span class="hs-identifier hs-var">ConflictingDefinitions</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SomeDefinitionTypeInfo origin
</span><a href="#local-6989586621689361490"><span class="hs-identifier hs-var">someNew</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">TypeOriginStack
</span><a href="#local-6989586621689361492"><span class="hs-identifier hs-var">stack</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SomeDefinitionTypeInfo origin
</span><a href="#local-6989586621689361484"><span class="hs-identifier hs-var">someOld</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">NonEmpty TypeOriginStack
</span><a href="#local-6989586621689361483"><span class="hs-identifier hs-var">origins</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-847"></span><span>
</span><span id="line-848"></span><span id="local-6989586621689361479"><span id="local-6989586621689361480"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#HasTypeDefinitions"><span class="hs-identifier hs-type">HasTypeDefinitions</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361480"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361479"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#HasTypeDefinitions"><span class="hs-identifier hs-type">HasTypeDefinitions</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361480"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621689361479"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-849"></span><span>  </span><span id="local-6989586621689361477"><span class="annot"><span class="annottext">accumulateTypeDefinitions :: [a] -&gt; TypeAccumulation origin ()
</span><a href="#local-6989586621689361477"><span class="hs-identifier hs-var hs-var hs-var hs-var">accumulateTypeDefinitions</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; TypeAccumulation origin ())
-&gt; [a] -&gt; TypeAccumulation origin ()
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Foldable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f ()
</span><span class="hs-identifier hs-var">traverse_</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span></span></span><span>
</span><span id="line-850"></span><span>
</span><span id="line-851"></span><span id="local-6989586621689361475"><span id="local-6989586621689361476"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#HasTypeDefinitions"><span class="hs-identifier hs-type">HasTypeDefinitions</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361476"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361475"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#HasTypeDefinitions"><span class="hs-identifier hs-type">HasTypeDefinitions</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361476"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621689361475"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-852"></span><span>  </span><span id="local-6989586621689361473"><span class="annot"><span class="annottext">accumulateTypeDefinitions :: Maybe a -&gt; TypeAccumulation origin ()
</span><a href="#local-6989586621689361473"><span class="hs-identifier hs-var hs-var hs-var hs-var">accumulateTypeDefinitions</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; TypeAccumulation origin ())
-&gt; Maybe a -&gt; TypeAccumulation origin ()
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Foldable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f ()
</span><span class="hs-identifier hs-var">traverse_</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span></span></span><span>
</span><span id="line-853"></span><span>
</span><span id="line-854"></span><span id="local-6989586621689361472"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#HasTypeDefinitions"><span class="hs-identifier hs-type">HasTypeDefinitions</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361472"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeDefinitionsWrapper"><span class="hs-identifier hs-type">TypeDefinitionsWrapper</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361472"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-855"></span><span>  </span><span id="local-6989586621689361470"><span class="annot"><span class="annottext">accumulateTypeDefinitions :: TypeDefinitionsWrapper origin -&gt; TypeAccumulation origin ()
</span><a href="#local-6989586621689361470"><span class="hs-identifier hs-var hs-var hs-var hs-var">accumulateTypeDefinitions</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeDefinitionsWrapper"><span class="hs-identifier hs-type">TypeDefinitionsWrapper</span></a></span><span> </span><span id="local-6989586621689361469"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621689361469"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621689361469"><span class="hs-identifier hs-var">x</span></a></span></span><span>
</span><span id="line-856"></span><span>
</span><span id="line-857"></span><span id="local-6989586621689361467"><span id="local-6989586621689361468"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#HasTypeDefinitions"><span class="hs-identifier hs-type">HasTypeDefinitions</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361468"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361468"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361467"><span class="hs-identifier hs-type">k</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-858"></span><span>  </span><span id="local-6989586621689361465"><span class="annot"><span class="annottext">accumulateTypeDefinitions :: Type origin k -&gt; TypeAccumulation origin ()
</span><a href="#local-6989586621689361465"><span class="hs-identifier hs-var hs-var hs-var hs-var">accumulateTypeDefinitions</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-859"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TNamed"><span class="hs-identifier hs-type">TNamed</span></a></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621689361464"><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
</span><a href="#local-6989586621689361464"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k) -&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span><span> </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin k)
</span><a href="#local-6989586621689361464"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-860"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TList"><span class="hs-identifier hs-type">TList</span></a></span><span> </span><span class="annot"><span class="annottext">Nullability
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621689361463"><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361463"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type origin k -&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span><span> </span><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361463"><span class="hs-identifier hs-var">t</span></a></span></span></span><span>
</span><span id="line-861"></span><span>
</span><span id="line-862"></span><span id="local-6989586621689361461"><span id="local-6989586621689361462"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#HasTypeDefinitions"><span class="hs-identifier hs-type">HasTypeDefinitions</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361462"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TypeInfo"><span class="hs-identifier hs-type">TypeInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361462"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361461"><span class="hs-identifier hs-type">k</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-863"></span><span>  </span><span id="local-6989586621689361459"><span class="annot"><span class="annottext">accumulateTypeDefinitions :: TypeInfo origin k -&gt; TypeAccumulation origin ()
</span><a href="#local-6989586621689361459"><span class="hs-identifier hs-var hs-var hs-var hs-var">accumulateTypeDefinitions</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-864"></span><span>    </span><span class="annot"><span class="annottext">TypeInfo origin k
</span><a href="Hasura.GraphQL.Parser.Schema.html#TIScalar"><span class="hs-identifier hs-var">TIScalar</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">() -&gt; TypeAccumulation origin ()
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-865"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIEnum"><span class="hs-identifier hs-type">TIEnum</span></a></span><span> </span><span class="annot"><span class="annottext">NonEmpty (Definition origin EnumValueInfo)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">() -&gt; TypeAccumulation origin ()
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-866"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIInputObject"><span class="hs-identifier hs-type">TIInputObject</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputObjectInfo"><span class="hs-identifier hs-type">InputObjectInfo</span></a></span><span> </span><span id="local-6989586621689361458"><span class="annot"><span class="annottext">[Definition origin (InputFieldInfo origin)]
</span><a href="#local-6989586621689361458"><span class="hs-identifier hs-var">fields</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Definition origin (InputFieldInfo origin)]
-&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (InputFieldInfo origin)]
</span><a href="#local-6989586621689361458"><span class="hs-identifier hs-var">fields</span></a></span><span>
</span><span id="line-867"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIObject"><span class="hs-identifier hs-type">TIObject</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ObjectInfo"><span class="hs-identifier hs-type">ObjectInfo</span></a></span><span> </span><span id="local-6989586621689361457"><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
</span><a href="#local-6989586621689361457"><span class="hs-identifier hs-var">fields</span></a></span></span><span> </span><span id="local-6989586621689361456"><span class="annot"><span class="annottext">[Definition origin (InterfaceInfo origin)]
</span><a href="#local-6989586621689361456"><span class="hs-identifier hs-var">interfaces</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-868"></span><span>      </span><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
-&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
</span><a href="#local-6989586621689361457"><span class="hs-identifier hs-var">fields</span></a></span><span> </span><span class="annot"><span class="annottext">TypeAccumulation origin ()
-&gt; TypeAccumulation origin () -&gt; TypeAccumulation origin ()
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Definition origin (InterfaceInfo origin)]
-&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (InterfaceInfo origin)]
</span><a href="#local-6989586621689361456"><span class="hs-identifier hs-var">interfaces</span></a></span><span>
</span><span id="line-869"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIInterface"><span class="hs-identifier hs-type">TIInterface</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InterfaceInfo"><span class="hs-identifier hs-type">InterfaceInfo</span></a></span><span> </span><span id="local-6989586621689361455"><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
</span><a href="#local-6989586621689361455"><span class="hs-identifier hs-var">fields</span></a></span></span><span> </span><span id="local-6989586621689361454"><span class="annot"><span class="annottext">[Definition origin (ObjectInfo origin)]
</span><a href="#local-6989586621689361454"><span class="hs-identifier hs-var">objects</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-870"></span><span>      </span><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
-&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (FieldInfo origin)]
</span><a href="#local-6989586621689361455"><span class="hs-identifier hs-var">fields</span></a></span><span>
</span><span id="line-871"></span><span>        </span><span class="annot"><span class="annottext">TypeAccumulation origin ()
-&gt; TypeAccumulation origin () -&gt; TypeAccumulation origin ()
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Definition origin (ObjectInfo origin)]
-&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (ObjectInfo origin)]
</span><a href="#local-6989586621689361454"><span class="hs-identifier hs-var">objects</span></a></span><span>
</span><span id="line-872"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#TIUnion"><span class="hs-identifier hs-type">TIUnion</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#UnionInfo"><span class="hs-identifier hs-type">UnionInfo</span></a></span><span> </span><span id="local-6989586621689361453"><span class="annot"><span class="annottext">[Definition origin (ObjectInfo origin)]
</span><a href="#local-6989586621689361453"><span class="hs-identifier hs-var">objects</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Definition origin (ObjectInfo origin)]
-&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (ObjectInfo origin)]
</span><a href="#local-6989586621689361453"><span class="hs-identifier hs-var">objects</span></a></span></span></span><span>
</span><span id="line-873"></span><span>
</span><span id="line-874"></span><span id="local-6989586621689361452"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#HasTypeDefinitions"><span class="hs-identifier hs-type">HasTypeDefinitions</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361452"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361452"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputObjectInfo"><span class="hs-identifier hs-type">InputObjectInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361452"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-875"></span><span>  </span><span id="local-6989586621689361450"><span class="annot"><span class="annottext">accumulateTypeDefinitions :: Definition origin (InputObjectInfo origin)
-&gt; TypeAccumulation origin ()
</span><a href="#local-6989586621689361450"><span class="hs-identifier hs-var hs-var hs-var hs-var">accumulateTypeDefinitions</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin 'Input)
-&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span><span> </span><span class="annot"><span class="annottext">(Definition origin (TypeInfo origin 'Input)
 -&gt; TypeAccumulation origin ())
-&gt; (Definition origin (InputObjectInfo origin)
    -&gt; Definition origin (TypeInfo origin 'Input))
-&gt; Definition origin (InputObjectInfo origin)
-&gt; TypeAccumulation origin ()
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(InputObjectInfo origin -&gt; TypeInfo origin 'Input)
-&gt; Definition origin (InputObjectInfo origin)
-&gt; Definition origin (TypeInfo origin 'Input)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">InputObjectInfo origin -&gt; TypeInfo origin 'Input
forall origin. InputObjectInfo origin -&gt; TypeInfo origin 'Input
</span><a href="Hasura.GraphQL.Parser.Schema.html#TIInputObject"><span class="hs-identifier hs-var">TIInputObject</span></a></span></span><span>
</span><span id="line-876"></span><span>
</span><span id="line-877"></span><span id="local-6989586621689361449"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#HasTypeDefinitions"><span class="hs-identifier hs-type">HasTypeDefinitions</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361449"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361449"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputFieldInfo"><span class="hs-identifier hs-type">InputFieldInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361449"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-878"></span><span>  </span><span id="local-6989586621689361447"><span class="annot"><span class="annottext">accumulateTypeDefinitions :: Definition origin (InputFieldInfo origin)
-&gt; TypeAccumulation origin ()
</span><a href="#local-6989586621689361447"><span class="hs-identifier hs-var hs-var hs-var hs-var">accumulateTypeDefinitions</span></a></span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="hs-special">{</span><span id="local-6989586621689361442"><span id="local-6989586621689361443"><span id="local-6989586621689361444"><span id="local-6989586621689361445"><span id="local-6989586621689361446"><span class="annot"><span class="annottext">[Directive Void]
Maybe origin
Maybe Description
Name
InputFieldInfo origin
dInfo :: InputFieldInfo origin
dDirectives :: [Directive Void]
dOrigin :: Maybe origin
dDescription :: Maybe Description
dName :: Name
dDirectives :: forall origin a. Definition origin a -&gt; [Directive Void]
dOrigin :: forall origin a. Definition origin a -&gt; Maybe origin
dDescription :: forall origin a. Definition origin a -&gt; Maybe Description
dInfo :: forall origin a. Definition origin a -&gt; a
dName :: forall origin a. Definition origin a -&gt; Name
</span><a href="#local-6989586621689361442"><span class="hs-glyph hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">..</span></a></span></span></span></span></span></span><span class="hs-special">}</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-879"></span><span>    </span><span class="annot"><span class="annottext">(TypeOriginStack -&gt; TypeOriginStack)
-&gt; TypeAccumulation origin () -&gt; TypeAccumulation origin ()
forall r (m :: * -&gt; *) a. MonadReader r m =&gt; (r -&gt; r) -&gt; m a -&gt; m a
</span><span class="hs-identifier hs-var">local</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; TypeOriginStack -&gt; TypeOriginStack
</span><a href="Hasura.GraphQL.Parser.Schema.html#typeOriginRecurse"><span class="hs-identifier hs-var">typeOriginRecurse</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361446"><span class="hs-identifier hs-var">dName</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(TypeAccumulation origin () -&gt; TypeAccumulation origin ())
-&gt; TypeAccumulation origin () -&gt; TypeAccumulation origin ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">InputFieldInfo origin -&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span><span> </span><span class="annot"><span class="annottext">InputFieldInfo origin
</span><a href="#local-6989586621689361442"><span class="hs-identifier hs-var">dInfo</span></a></span></span><span>
</span><span id="line-880"></span><span>
</span><span id="line-881"></span><span id="local-6989586621689361441"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#HasTypeDefinitions"><span class="hs-identifier hs-type">HasTypeDefinitions</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361441"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputFieldInfo"><span class="hs-identifier hs-type">InputFieldInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361441"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-882"></span><span>  </span><span id="local-6989586621689361439"><span class="annot"><span class="annottext">accumulateTypeDefinitions :: InputFieldInfo origin -&gt; TypeAccumulation origin ()
</span><a href="#local-6989586621689361439"><span class="hs-identifier hs-var hs-var hs-var hs-var">accumulateTypeDefinitions</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InputFieldInfo"><span class="hs-identifier hs-type">InputFieldInfo</span></a></span><span> </span><span id="local-6989586621689361438"><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361438"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe (Value Void)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-883"></span><span>    </span><span class="annot"><span class="annottext">Type origin k -&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span><span> </span><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361438"><span class="hs-identifier hs-var">t</span></a></span></span><span>
</span><span id="line-884"></span><span>
</span><span id="line-885"></span><span id="local-6989586621689361437"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#HasTypeDefinitions"><span class="hs-identifier hs-type">HasTypeDefinitions</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361437"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361437"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#FieldInfo"><span class="hs-identifier hs-type">FieldInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361437"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-886"></span><span>  </span><span id="local-6989586621689361435"><span class="annot"><span class="annottext">accumulateTypeDefinitions :: Definition origin (FieldInfo origin) -&gt; TypeAccumulation origin ()
</span><a href="#local-6989586621689361435"><span class="hs-identifier hs-var hs-var hs-var hs-var">accumulateTypeDefinitions</span></a></span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="hs-special">{</span><span id="local-6989586621689361430"><span id="local-6989586621689361431"><span id="local-6989586621689361432"><span id="local-6989586621689361433"><span id="local-6989586621689361434"><span class="annot"><span class="annottext">[Directive Void]
Maybe origin
Maybe Description
Name
FieldInfo origin
dInfo :: FieldInfo origin
dDirectives :: [Directive Void]
dOrigin :: Maybe origin
dDescription :: Maybe Description
dName :: Name
dDirectives :: forall origin a. Definition origin a -&gt; [Directive Void]
dOrigin :: forall origin a. Definition origin a -&gt; Maybe origin
dDescription :: forall origin a. Definition origin a -&gt; Maybe Description
dInfo :: forall origin a. Definition origin a -&gt; a
dName :: forall origin a. Definition origin a -&gt; Name
</span><a href="#local-6989586621689361430"><span class="hs-glyph hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">..</span></a></span></span></span></span></span></span><span class="hs-special">}</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-887"></span><span>    </span><span class="annot"><span class="annottext">(TypeOriginStack -&gt; TypeOriginStack)
-&gt; TypeAccumulation origin () -&gt; TypeAccumulation origin ()
forall r (m :: * -&gt; *) a. MonadReader r m =&gt; (r -&gt; r) -&gt; m a -&gt; m a
</span><span class="hs-identifier hs-var">local</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; TypeOriginStack -&gt; TypeOriginStack
</span><a href="Hasura.GraphQL.Parser.Schema.html#typeOriginRecurse"><span class="hs-identifier hs-var">typeOriginRecurse</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361434"><span class="hs-identifier hs-var">dName</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(TypeAccumulation origin () -&gt; TypeAccumulation origin ())
-&gt; TypeAccumulation origin () -&gt; TypeAccumulation origin ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">FieldInfo origin -&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span><span> </span><span class="annot"><span class="annottext">FieldInfo origin
</span><a href="#local-6989586621689361430"><span class="hs-identifier hs-var">dInfo</span></a></span></span><span>
</span><span id="line-888"></span><span>
</span><span id="line-889"></span><span id="local-6989586621689361429"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#HasTypeDefinitions"><span class="hs-identifier hs-type">HasTypeDefinitions</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361429"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#FieldInfo"><span class="hs-identifier hs-type">FieldInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361429"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-890"></span><span>  </span><span id="local-6989586621689361427"><span class="annot"><span class="annottext">accumulateTypeDefinitions :: FieldInfo origin -&gt; TypeAccumulation origin ()
</span><a href="#local-6989586621689361427"><span class="hs-identifier hs-var hs-var hs-var hs-var">accumulateTypeDefinitions</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#FieldInfo"><span class="hs-identifier hs-type">FieldInfo</span></a></span><span> </span><span id="local-6989586621689361426"><span class="annot"><span class="annottext">[Definition origin (InputFieldInfo origin)]
</span><a href="#local-6989586621689361426"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span id="local-6989586621689361425"><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361425"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-891"></span><span>    </span><span class="annot"><span class="annottext">[Definition origin (InputFieldInfo origin)]
-&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span><span> </span><span class="annot"><span class="annottext">[Definition origin (InputFieldInfo origin)]
</span><a href="#local-6989586621689361426"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-892"></span><span>    </span><span class="annot"><span class="annottext">Type origin k -&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span><span> </span><span class="annot"><span class="annottext">Type origin k
</span><a href="#local-6989586621689361425"><span class="hs-identifier hs-var">t</span></a></span></span><span>
</span><span id="line-893"></span><span>
</span><span id="line-894"></span><span id="local-6989586621689361424"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#HasTypeDefinitions"><span class="hs-identifier hs-type">HasTypeDefinitions</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361424"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361424"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#ObjectInfo"><span class="hs-identifier hs-type">ObjectInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361424"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-895"></span><span>  </span><span id="local-6989586621689361422"><span class="annot"><span class="annottext">accumulateTypeDefinitions :: Definition origin (ObjectInfo origin) -&gt; TypeAccumulation origin ()
</span><a href="#local-6989586621689361422"><span class="hs-identifier hs-var hs-var hs-var hs-var">accumulateTypeDefinitions</span></a></span></span><span> </span><span id="local-6989586621689361421"><span class="annot"><span class="annottext">d :: Definition origin (ObjectInfo origin)
</span><a href="#local-6989586621689361421"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="hs-special">{</span><span id="local-6989586621689361416"><span id="local-6989586621689361417"><span id="local-6989586621689361418"><span id="local-6989586621689361419"><span id="local-6989586621689361420"><span class="annot"><span class="annottext">[Directive Void]
Maybe origin
Maybe Description
Name
ObjectInfo origin
dInfo :: ObjectInfo origin
dDirectives :: [Directive Void]
dOrigin :: Maybe origin
dDescription :: Maybe Description
dName :: Name
dDirectives :: forall origin a. Definition origin a -&gt; [Directive Void]
dOrigin :: forall origin a. Definition origin a -&gt; Maybe origin
dDescription :: forall origin a. Definition origin a -&gt; Maybe Description
dInfo :: forall origin a. Definition origin a -&gt; a
dName :: forall origin a. Definition origin a -&gt; Name
</span><a href="#local-6989586621689361416"><span class="hs-glyph hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">..</span></a></span></span></span></span></span></span><span class="hs-special">}</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-896"></span><span>    </span><span class="annot"><span class="annottext">(TypeOriginStack -&gt; TypeOriginStack)
-&gt; TypeAccumulation origin () -&gt; TypeAccumulation origin ()
forall r (m :: * -&gt; *) a. MonadReader r m =&gt; (r -&gt; r) -&gt; m a -&gt; m a
</span><span class="hs-identifier hs-var">local</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; TypeOriginStack -&gt; TypeOriginStack
</span><a href="Hasura.GraphQL.Parser.Schema.html#typeOriginRecurse"><span class="hs-identifier hs-var">typeOriginRecurse</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361420"><span class="hs-identifier hs-var">dName</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(TypeAccumulation origin () -&gt; TypeAccumulation origin ())
-&gt; TypeAccumulation origin () -&gt; TypeAccumulation origin ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin 'Output)
-&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(ObjectInfo origin -&gt; TypeInfo origin 'Output)
-&gt; Definition origin (ObjectInfo origin)
-&gt; Definition origin (TypeInfo origin 'Output)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">ObjectInfo origin -&gt; TypeInfo origin 'Output
forall origin. ObjectInfo origin -&gt; TypeInfo origin 'Output
</span><a href="Hasura.GraphQL.Parser.Schema.html#TIObject"><span class="hs-identifier hs-var">TIObject</span></a></span><span> </span><span class="annot"><span class="annottext">Definition origin (ObjectInfo origin)
</span><a href="#local-6989586621689361421"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-897"></span><span>
</span><span id="line-898"></span><span id="local-6989586621689361415"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#HasTypeDefinitions"><span class="hs-identifier hs-type">HasTypeDefinitions</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361415"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361415"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#InterfaceInfo"><span class="hs-identifier hs-type">InterfaceInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361415"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-899"></span><span>  </span><span id="local-6989586621689361413"><span class="annot"><span class="annottext">accumulateTypeDefinitions :: Definition origin (InterfaceInfo origin)
-&gt; TypeAccumulation origin ()
</span><a href="#local-6989586621689361413"><span class="hs-identifier hs-var hs-var hs-var hs-var">accumulateTypeDefinitions</span></a></span></span><span> </span><span id="local-6989586621689361412"><span class="annot"><span class="annottext">d :: Definition origin (InterfaceInfo origin)
</span><a href="#local-6989586621689361412"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="hs-special">{</span><span id="local-6989586621689361407"><span id="local-6989586621689361408"><span id="local-6989586621689361409"><span id="local-6989586621689361410"><span id="local-6989586621689361411"><span class="annot"><span class="annottext">[Directive Void]
Maybe origin
Maybe Description
Name
InterfaceInfo origin
dInfo :: InterfaceInfo origin
dDirectives :: [Directive Void]
dOrigin :: Maybe origin
dDescription :: Maybe Description
dName :: Name
dDirectives :: forall origin a. Definition origin a -&gt; [Directive Void]
dOrigin :: forall origin a. Definition origin a -&gt; Maybe origin
dDescription :: forall origin a. Definition origin a -&gt; Maybe Description
dInfo :: forall origin a. Definition origin a -&gt; a
dName :: forall origin a. Definition origin a -&gt; Name
</span><a href="#local-6989586621689361407"><span class="hs-glyph hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">..</span></a></span></span></span></span></span></span><span class="hs-special">}</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-900"></span><span>    </span><span class="annot"><span class="annottext">(TypeOriginStack -&gt; TypeOriginStack)
-&gt; TypeAccumulation origin () -&gt; TypeAccumulation origin ()
forall r (m :: * -&gt; *) a. MonadReader r m =&gt; (r -&gt; r) -&gt; m a -&gt; m a
</span><span class="hs-identifier hs-var">local</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; TypeOriginStack -&gt; TypeOriginStack
</span><a href="Hasura.GraphQL.Parser.Schema.html#typeOriginRecurse"><span class="hs-identifier hs-var">typeOriginRecurse</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361411"><span class="hs-identifier hs-var">dName</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(TypeAccumulation origin () -&gt; TypeAccumulation origin ())
-&gt; TypeAccumulation origin () -&gt; TypeAccumulation origin ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin 'Output)
-&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(InterfaceInfo origin -&gt; TypeInfo origin 'Output)
-&gt; Definition origin (InterfaceInfo origin)
-&gt; Definition origin (TypeInfo origin 'Output)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">InterfaceInfo origin -&gt; TypeInfo origin 'Output
forall origin. InterfaceInfo origin -&gt; TypeInfo origin 'Output
</span><a href="Hasura.GraphQL.Parser.Schema.html#TIInterface"><span class="hs-identifier hs-var">TIInterface</span></a></span><span> </span><span class="annot"><span class="annottext">Definition origin (InterfaceInfo origin)
</span><a href="#local-6989586621689361412"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-901"></span><span>
</span><span id="line-902"></span><span id="local-6989586621689361406"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#HasTypeDefinitions"><span class="hs-identifier hs-type">HasTypeDefinitions</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361406"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361406"><span class="hs-identifier hs-type">origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#UnionInfo"><span class="hs-identifier hs-type">UnionInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689361406"><span class="hs-identifier hs-type">origin</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-903"></span><span>  </span><span id="local-6989586621689361404"><span class="annot"><span class="annottext">accumulateTypeDefinitions :: Definition origin (UnionInfo origin) -&gt; TypeAccumulation origin ()
</span><a href="#local-6989586621689361404"><span class="hs-identifier hs-var hs-var hs-var hs-var">accumulateTypeDefinitions</span></a></span></span><span> </span><span id="local-6989586621689361403"><span class="annot"><span class="annottext">d :: Definition origin (UnionInfo origin)
</span><a href="#local-6989586621689361403"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="Hasura.GraphQL.Parser.Schema.html#Definition"><span class="hs-identifier hs-type">Definition</span></a></span><span> </span><span class="hs-special">{</span><span id="local-6989586621689361398"><span id="local-6989586621689361399"><span id="local-6989586621689361400"><span id="local-6989586621689361401"><span id="local-6989586621689361402"><span class="annot"><span class="annottext">[Directive Void]
Maybe origin
Maybe Description
Name
UnionInfo origin
dInfo :: UnionInfo origin
dDirectives :: [Directive Void]
dOrigin :: Maybe origin
dDescription :: Maybe Description
dName :: Name
dDirectives :: forall origin a. Definition origin a -&gt; [Directive Void]
dOrigin :: forall origin a. Definition origin a -&gt; Maybe origin
dDescription :: forall origin a. Definition origin a -&gt; Maybe Description
dInfo :: forall origin a. Definition origin a -&gt; a
dName :: forall origin a. Definition origin a -&gt; Name
</span><a href="#local-6989586621689361398"><span class="hs-glyph hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">..</span></a></span></span></span></span></span></span><span class="hs-special">}</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-904"></span><span>    </span><span class="annot"><span class="annottext">(TypeOriginStack -&gt; TypeOriginStack)
-&gt; TypeAccumulation origin () -&gt; TypeAccumulation origin ()
forall r (m :: * -&gt; *) a. MonadReader r m =&gt; (r -&gt; r) -&gt; m a -&gt; m a
</span><span class="hs-identifier hs-var">local</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; TypeOriginStack -&gt; TypeOriginStack
</span><a href="Hasura.GraphQL.Parser.Schema.html#typeOriginRecurse"><span class="hs-identifier hs-var">typeOriginRecurse</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689361402"><span class="hs-identifier hs-var">dName</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(TypeAccumulation origin () -&gt; TypeAccumulation origin ())
-&gt; TypeAccumulation origin () -&gt; TypeAccumulation origin ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Definition origin (TypeInfo origin 'Output)
-&gt; TypeAccumulation origin ()
forall origin a.
HasTypeDefinitions origin a =&gt;
a -&gt; TypeAccumulation origin ()
</span><a href="Hasura.GraphQL.Parser.Schema.html#accumulateTypeDefinitions"><span class="hs-identifier hs-var">accumulateTypeDefinitions</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(UnionInfo origin -&gt; TypeInfo origin 'Output)
-&gt; Definition origin (UnionInfo origin)
-&gt; Definition origin (TypeInfo origin 'Output)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">UnionInfo origin -&gt; TypeInfo origin 'Output
forall origin. UnionInfo origin -&gt; TypeInfo origin 'Output
</span><a href="Hasura.GraphQL.Parser.Schema.html#TIUnion"><span class="hs-identifier hs-var">TIUnion</span></a></span><span> </span><span class="annot"><span class="annottext">Definition origin (UnionInfo origin)
</span><a href="#local-6989586621689361403"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-905"></span><span>
</span><span id="line-906"></span><span class="hs-comment">{- PERFORMANCE NOTE/TODO:

Since Definition's are cyclic I spent a little time trying to optimize the
== in accumulateTypeDefinitions into a nearly-noop using pointer
equality, but could not get it to trigger unless I called it on the unlifted
ByteArray# within dName, but at that point what was a pretty small theoretical
benefit disappeared for whatever reason (plus wasn't strictly safe at that
point). (Note, to have any luck calling on Definitions directly we would need
to fix the reallocation of Definitions via @fmap TI...@ in
accumulateTypeDefinitions as well)

The TODO-flavored thing here is to investigate whether we might not have as
much sharing here as we assume. We can use ghc-debug to inspect the object in
the heap.

We might also then rewrite accumulateTypeDefinitions to return non-cyclic type
definition segmants corresponding to the equality logic here (see &quot;dodgy&quot;
equality comments), and even consider trying to do some kind of global
interning of these across roles (though I think that would only be an
very incremental improvement...)

-- | See e.g. https://github.com/haskell/containers/blob/master/containers/src/Utils/Containers/Internal/PtrEquality.hs
--
-- If this returns True then the arguments are equal (for any sane definition of equality)
-- if this returns False nothing can be determined. The caller must ensure
-- referential transparency is preserved...
unsafeHetPtrEq :: a -&gt; b -&gt; Bool
unsafeHetPtrEq !x !y = isTrue# (unsafeCoerce (reallyUnsafePtrEquality# :: x -&gt; x -&gt; Int#) x y)
{-# INLINE unsafeHetPtrEq #-}
infix 4 `unsafeHetPtrEq` -- just like (==)

-- | Equivalent to @(==)@ but potentially faster in cases where the arguments
-- might be pointer-identical.
fastEq :: (Eq a)=&gt; a -&gt; a -&gt; Bool
fastEq !x !y =
  -- See e.g. https://github.com/haskell/containers/blob/master/containers/src/Utils/Containers/Internal/PtrEquality.hs
  isTrue# (reallyUnsafePtrEquality# x y) || x == y

infix 4 `fastEq` -- just like (==)
-}</span><span>
</span><span id="line-946"></span></pre></body></html>