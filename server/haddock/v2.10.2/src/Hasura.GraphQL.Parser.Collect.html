<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-comment">-- | This module implements two parts of the GraphQL specification:</span><span>
</span><span id="line-2"></span><span class="hs-comment">--</span><span>
</span><span id="line-3"></span><span class="hs-comment">--  1. &lt;&#167; 5.3.2 Field Selection Merging http://spec.graphql.org/June2018/#sec-Field-Selection-Merging&gt;</span><span>
</span><span id="line-4"></span><span class="hs-comment">--  2. &lt;&#167; 6.3.2 Field Collection http://spec.graphql.org/June2018/#sec-Field-Collection&gt;</span><span>
</span><span id="line-5"></span><span class="hs-comment">--</span><span>
</span><span id="line-6"></span><span class="hs-comment">-- These are described in completely different sections of the specification, but</span><span>
</span><span id="line-7"></span><span class="hs-comment">-- they&#8217;re actually highly related: both essentially normalize fields in a</span><span>
</span><span id="line-8"></span><span class="hs-comment">-- selection set.</span><span>
</span><span id="line-9"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Hasura.GraphQL.Parser.Collect</span><span>
</span><span id="line-10"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Collect.html#collectFields"><span class="hs-identifier">collectFields</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-11"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-12"></span><span class="hs-keyword">where</span><span>
</span><span id="line-13"></span><span>
</span><span id="line-14"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">foldM</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">unless</span></span><span class="hs-special">)</span><span>
</span><span id="line-15"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.HashMap.Strict.InsOrd</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">InsOrdHashMap</span></span><span class="hs-special">)</span><span>
</span><span id="line-16"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.HashMap.Strict.InsOrd</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">OMap</span></span><span>
</span><span id="line-17"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">fromMaybe</span></span><span class="hs-special">)</span><span>
</span><span id="line-18"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../file:///workdir/dist-newstyle/build/x86_64-linux/ghc-8.10.7/hasura-error-message-1.0.0/opt/doc/html/hasura-error-message/src"><span class="hs-identifier">Hasura.Base.ToErrorValue</span></a></span><span>
</span><span id="line-19"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Class.html"><span class="hs-identifier">Hasura.GraphQL.Parser.Class</span></a></span><span>
</span><span id="line-20"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Directives.html"><span class="hs-identifier">Hasura.GraphQL.Parser.Directives</span></a></span><span>
</span><span id="line-21"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Variable.html"><span class="hs-identifier">Hasura.GraphQL.Parser.Variable</span></a></span><span>
</span><span id="line-22"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Language.GraphQL.Draft.Syntax</span></span><span>
</span><span id="line-23"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Prelude</span></span><span>
</span><span id="line-24"></span><span>
</span><span id="line-25"></span><span class="hs-comment">-- | Collects the effective set of fields queried by a selection set by</span><span>
</span><span id="line-26"></span><span class="hs-comment">-- flattening fragments and merging duplicate fields.</span><span>
</span><span id="line-27"></span><span id="local-6989586621689408613"><span id="local-6989586621689408614"><span class="annot"><a href="Hasura.GraphQL.Parser.Collect.html#collectFields"><span class="hs-identifier hs-type">collectFields</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-28"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Class.Parse.html#MonadParse"><span class="hs-identifier hs-type">MonadParse</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689408614"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621689408613"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-29"></span><span>  </span><span class="hs-comment">-- | The names of the object types and interface types the 'SelectionSet' is</span><span>
</span><span id="line-30"></span><span>  </span><span class="hs-comment">-- selecting against.</span><span>
</span><span id="line-31"></span><span>  </span><span class="annot"><a href="#local-6989586621689408613"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-32"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">SelectionSet</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NoFragments</span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Variable.html#Variable"><span class="hs-identifier hs-type">Variable</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-33"></span><span>  </span><span class="annot"><a href="#local-6989586621689408614"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">InsOrdHashMap</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Field</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NoFragments</span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Variable.html#Variable"><span class="hs-identifier hs-type">Variable</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-34"></span><span id="collectFields"><span class="annot"><span class="annottext">collectFields :: t Name
-&gt; SelectionSet NoFragments Variable
-&gt; m (InsOrdHashMap Name (Field NoFragments Variable))
</span><a href="Hasura.GraphQL.Parser.Collect.html#collectFields"><span class="hs-identifier hs-var hs-var">collectFields</span></a></span></span><span> </span><span id="local-6989586621689408612"><span class="annot"><span class="annottext">t Name
</span><a href="#local-6989586621689408612"><span class="hs-identifier hs-var">objectTypeNames</span></a></span></span><span> </span><span id="local-6989586621689408611"><span class="annot"><span class="annottext">SelectionSet NoFragments Variable
</span><a href="#local-6989586621689408611"><span class="hs-identifier hs-var">selectionSet</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-35"></span><span>  </span><span class="annot"><span class="annottext">[Field NoFragments Variable]
-&gt; m (InsOrdHashMap Name (Field NoFragments Variable))
forall (m :: * -&gt; *) var.
(MonadParse m, Eq var) =&gt;
[Field NoFragments var]
-&gt; m (InsOrdHashMap Name (Field NoFragments var))
</span><a href="Hasura.GraphQL.Parser.Collect.html#mergeFields"><span class="hs-identifier hs-var">mergeFields</span></a></span><span> </span><span class="annot"><span class="annottext">([Field NoFragments Variable]
 -&gt; m (InsOrdHashMap Name (Field NoFragments Variable)))
-&gt; m [Field NoFragments Variable]
-&gt; m (InsOrdHashMap Name (Field NoFragments Variable))
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">t Name
-&gt; SelectionSet NoFragments Variable
-&gt; m [Field NoFragments Variable]
forall (m :: * -&gt; *) (t :: * -&gt; *).
(MonadParse m, Foldable t) =&gt;
t Name
-&gt; SelectionSet NoFragments Variable
-&gt; m [Field NoFragments Variable]
</span><a href="Hasura.GraphQL.Parser.Collect.html#flattenSelectionSet"><span class="hs-identifier hs-var">flattenSelectionSet</span></a></span><span> </span><span class="annot"><span class="annottext">t Name
</span><a href="#local-6989586621689408612"><span class="hs-identifier hs-var">objectTypeNames</span></a></span><span> </span><span class="annot"><span class="annottext">SelectionSet NoFragments Variable
</span><a href="#local-6989586621689408611"><span class="hs-identifier hs-var">selectionSet</span></a></span><span>
</span><span id="line-36"></span><span>
</span><span id="line-37"></span><span class="hs-comment">-- | Flattens inline fragments in a selection set. For example,</span><span>
</span><span id="line-38"></span><span class="hs-comment">--</span><span>
</span><span id="line-39"></span><span class="hs-comment">-- &gt; {</span><span>
</span><span id="line-40"></span><span class="hs-comment">-- &gt;   bar</span><span>
</span><span id="line-41"></span><span class="hs-comment">-- &gt;   ... on Foo {</span><span>
</span><span id="line-42"></span><span class="hs-comment">-- &gt;     baz</span><span>
</span><span id="line-43"></span><span class="hs-comment">-- &gt;     qux</span><span>
</span><span id="line-44"></span><span class="hs-comment">-- &gt;   }</span><span>
</span><span id="line-45"></span><span class="hs-comment">-- &gt; }</span><span>
</span><span id="line-46"></span><span class="hs-comment">--</span><span>
</span><span id="line-47"></span><span class="hs-comment">-- is flattened to:</span><span>
</span><span id="line-48"></span><span class="hs-comment">--</span><span>
</span><span id="line-49"></span><span class="hs-comment">-- &gt; {</span><span>
</span><span id="line-50"></span><span class="hs-comment">-- &gt;   bar</span><span>
</span><span id="line-51"></span><span class="hs-comment">-- &gt;   baz</span><span>
</span><span id="line-52"></span><span class="hs-comment">-- &gt;   qux</span><span>
</span><span id="line-53"></span><span class="hs-comment">-- &gt; }</span><span>
</span><span id="line-54"></span><span class="hs-comment">--</span><span>
</span><span id="line-55"></span><span class="hs-comment">-- Nested fragments are similarly flattened, but only as is necessary: fragments</span><span>
</span><span id="line-56"></span><span class="hs-comment">-- inside subselection sets of individual fields are /not/ flattened. For</span><span>
</span><span id="line-57"></span><span class="hs-comment">-- example,</span><span>
</span><span id="line-58"></span><span class="hs-comment">--</span><span>
</span><span id="line-59"></span><span class="hs-comment">-- &gt; {</span><span>
</span><span id="line-60"></span><span class="hs-comment">-- &gt;   bar</span><span>
</span><span id="line-61"></span><span class="hs-comment">-- &gt;   ... on Foo {</span><span>
</span><span id="line-62"></span><span class="hs-comment">-- &gt;     baz {</span><span>
</span><span id="line-63"></span><span class="hs-comment">-- &gt;       ... on Baz {</span><span>
</span><span id="line-64"></span><span class="hs-comment">-- &gt;         foo</span><span>
</span><span id="line-65"></span><span class="hs-comment">-- &gt;       }</span><span>
</span><span id="line-66"></span><span class="hs-comment">-- &gt;     }</span><span>
</span><span id="line-67"></span><span class="hs-comment">-- &gt;     qux</span><span>
</span><span id="line-68"></span><span class="hs-comment">-- &gt;   }</span><span>
</span><span id="line-69"></span><span class="hs-comment">-- &gt; }</span><span>
</span><span id="line-70"></span><span class="hs-comment">--</span><span>
</span><span id="line-71"></span><span class="hs-comment">-- is flattened to</span><span>
</span><span id="line-72"></span><span class="hs-comment">--</span><span>
</span><span id="line-73"></span><span class="hs-comment">-- &gt; {</span><span>
</span><span id="line-74"></span><span class="hs-comment">-- &gt;   bar</span><span>
</span><span id="line-75"></span><span class="hs-comment">-- &gt;   baz {</span><span>
</span><span id="line-76"></span><span class="hs-comment">-- &gt;     ... on Baz {</span><span>
</span><span id="line-77"></span><span class="hs-comment">-- &gt;       foo</span><span>
</span><span id="line-78"></span><span class="hs-comment">-- &gt;     }</span><span>
</span><span id="line-79"></span><span class="hs-comment">-- &gt;   }</span><span>
</span><span id="line-80"></span><span class="hs-comment">-- &gt;   qux</span><span>
</span><span id="line-81"></span><span class="hs-comment">-- &gt; }</span><span>
</span><span id="line-82"></span><span class="hs-comment">--</span><span>
</span><span id="line-83"></span><span class="hs-comment">-- leaving the innermost fragment on @baz@ alone.</span><span>
</span><span id="line-84"></span><span class="hs-comment">--</span><span>
</span><span id="line-85"></span><span class="hs-comment">-- This function also applies @\@include@ and @\@skip@ directives, since they</span><span>
</span><span id="line-86"></span><span class="hs-comment">-- should be applied before fragments are flattened.</span><span>
</span><span id="line-87"></span><span id="local-6989586621689408709"><span id="local-6989586621689408710"><span class="annot"><a href="Hasura.GraphQL.Parser.Collect.html#flattenSelectionSet"><span class="hs-identifier hs-type">flattenSelectionSet</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-88"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Class.Parse.html#MonadParse"><span class="hs-identifier hs-type">MonadParse</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689408710"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621689408709"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-89"></span><span>  </span><span class="hs-comment">-- | The name of the object type the 'SelectionSet' is selecting against.</span><span>
</span><span id="line-90"></span><span>  </span><span class="annot"><a href="#local-6989586621689408709"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-91"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">SelectionSet</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NoFragments</span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Variable.html#Variable"><span class="hs-identifier hs-type">Variable</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-92"></span><span>  </span><span class="annot"><a href="#local-6989586621689408710"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Field</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NoFragments</span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Variable.html#Variable"><span class="hs-identifier hs-type">Variable</span></a></span><span class="hs-special">]</span></span></span><span>
</span><span id="line-93"></span><span id="flattenSelectionSet"><span class="annot"><span class="annottext">flattenSelectionSet :: t Name
-&gt; SelectionSet NoFragments Variable
-&gt; m [Field NoFragments Variable]
</span><a href="Hasura.GraphQL.Parser.Collect.html#flattenSelectionSet"><span class="hs-identifier hs-var hs-var">flattenSelectionSet</span></a></span></span><span> </span><span id="local-6989586621689408607"><span class="annot"><span class="annottext">t Name
</span><a href="#local-6989586621689408607"><span class="hs-identifier hs-var">objectTypeNames</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([[Field NoFragments Variable]] -&gt; [Field NoFragments Variable])
-&gt; m [[Field NoFragments Variable]]
-&gt; m [Field NoFragments Variable]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">[[Field NoFragments Variable]] -&gt; [Field NoFragments Variable]
forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><span class="hs-identifier hs-var">concat</span></span><span> </span><span class="annot"><span class="annottext">(m [[Field NoFragments Variable]]
 -&gt; m [Field NoFragments Variable])
-&gt; (SelectionSet NoFragments Variable
    -&gt; m [[Field NoFragments Variable]])
-&gt; SelectionSet NoFragments Variable
-&gt; m [Field NoFragments Variable]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Selection NoFragments Variable -&gt; m [Field NoFragments Variable])
-&gt; SelectionSet NoFragments Variable
-&gt; m [[Field NoFragments Variable]]
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><span class="hs-identifier hs-var">traverse</span></span><span> </span><span class="annot"><span class="annottext">Selection NoFragments Variable -&gt; m [Field NoFragments Variable]
</span><a href="#local-6989586621689408603"><span class="hs-identifier hs-var">flattenSelection</span></a></span><span>
</span><span id="line-94"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-95"></span><span>    </span><span class="hs-comment">-- The easy case: just a single field.</span><span>
</span><span id="line-96"></span><span>    </span><span id="local-6989586621689408603"><span class="annot"><span class="annottext">flattenSelection :: Selection NoFragments Variable -&gt; m [Field NoFragments Variable]
</span><a href="#local-6989586621689408603"><span class="hs-identifier hs-var hs-var">flattenSelection</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SelectionField</span></span><span> </span><span id="local-6989586621689408601"><span class="annot"><span class="annottext">Field NoFragments Variable
</span><a href="#local-6989586621689408601"><span class="hs-identifier hs-var">field</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-97"></span><span>      </span><span class="annot"><span class="annottext">ExecutableDirectiveLocation
-&gt; [Directive Variable]
-&gt; m [Field NoFragments Variable]
-&gt; m [Field NoFragments Variable]
forall (m :: * -&gt; *) a.
MonadParse m =&gt;
ExecutableDirectiveLocation
-&gt; [Directive Variable] -&gt; m [a] -&gt; m [a]
</span><a href="#local-6989586621689408600"><span class="hs-identifier hs-var">applyInclusionDirectives</span></a></span><span> </span><span class="annot"><span class="annottext">ExecutableDirectiveLocation
</span><span class="hs-identifier hs-var">EDLFIELD</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Field NoFragments Variable -&gt; [Directive Variable]
forall (frag :: * -&gt; *) var. Field frag var -&gt; [Directive var]
</span><span class="hs-identifier hs-var hs-var">_fDirectives</span></span><span> </span><span class="annot"><span class="annottext">Field NoFragments Variable
</span><a href="#local-6989586621689408601"><span class="hs-identifier hs-var">field</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(m [Field NoFragments Variable] -&gt; m [Field NoFragments Variable])
-&gt; m [Field NoFragments Variable] -&gt; m [Field NoFragments Variable]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Field NoFragments Variable] -&gt; m [Field NoFragments Variable]
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Field NoFragments Variable
</span><a href="#local-6989586621689408601"><span class="hs-identifier hs-var">field</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-98"></span><span>
</span><span id="line-99"></span><span>    </span><span class="hs-comment">-- Note: The 'SelectionFragmentSpread' case has already been eliminated by</span><span>
</span><span id="line-100"></span><span>    </span><span class="hs-comment">-- the fragment inliner.</span><span>
</span><span id="line-101"></span><span>    </span><span class="hs-comment">-- TODO: handle directives on fragment spread.</span><span>
</span><span id="line-102"></span><span>
</span><span id="line-103"></span><span>    </span><span class="hs-comment">-- The involved case: we have an inline fragment to process.</span><span>
</span><span id="line-104"></span><span>    </span><span class="annot"><a href="#local-6989586621689408603"><span class="hs-identifier hs-var">flattenSelection</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SelectionInlineFragment</span></span><span> </span><span id="local-6989586621689408596"><span class="annot"><span class="annottext">InlineFragment NoFragments Variable
</span><a href="#local-6989586621689408596"><span class="hs-identifier hs-var">fragment</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-105"></span><span>      </span><span class="annot"><span class="annottext">ExecutableDirectiveLocation
-&gt; [Directive Variable]
-&gt; m [Field NoFragments Variable]
-&gt; m [Field NoFragments Variable]
forall (m :: * -&gt; *) a.
MonadParse m =&gt;
ExecutableDirectiveLocation
-&gt; [Directive Variable] -&gt; m [a] -&gt; m [a]
</span><a href="#local-6989586621689408600"><span class="hs-identifier hs-var">applyInclusionDirectives</span></a></span><span> </span><span class="annot"><span class="annottext">ExecutableDirectiveLocation
</span><span class="hs-identifier hs-var">EDLINLINE_FRAGMENT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">InlineFragment NoFragments Variable -&gt; [Directive Variable]
forall (frag :: * -&gt; *) var.
InlineFragment frag var -&gt; [Directive var]
</span><span class="hs-identifier hs-var hs-var">_ifDirectives</span></span><span> </span><span class="annot"><span class="annottext">InlineFragment NoFragments Variable
</span><a href="#local-6989586621689408596"><span class="hs-identifier hs-var">fragment</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(m [Field NoFragments Variable] -&gt; m [Field NoFragments Variable])
-&gt; m [Field NoFragments Variable] -&gt; m [Field NoFragments Variable]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-106"></span><span>        </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">InlineFragment NoFragments Variable -&gt; Maybe Name
forall (frag :: * -&gt; *) var. InlineFragment frag var -&gt; Maybe Name
</span><span class="hs-identifier hs-var hs-var">_ifTypeCondition</span></span><span> </span><span class="annot"><span class="annottext">InlineFragment NoFragments Variable
</span><a href="#local-6989586621689408596"><span class="hs-identifier hs-var">fragment</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-107"></span><span>          </span><span class="hs-comment">-- No type condition, so the fragment unconditionally applies.</span><span>
</span><span id="line-108"></span><span>          </span><span class="annot"><span class="annottext">Maybe Name
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">InlineFragment NoFragments Variable
-&gt; m [Field NoFragments Variable]
</span><a href="#local-6989586621689408592"><span class="hs-identifier hs-var">flattenInlineFragment</span></a></span><span> </span><span class="annot"><span class="annottext">InlineFragment NoFragments Variable
</span><a href="#local-6989586621689408596"><span class="hs-identifier hs-var">fragment</span></a></span><span>
</span><span id="line-109"></span><span>          </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621689408591"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689408591"><span class="hs-identifier hs-var">typeName</span></a></span></span><span>
</span><span id="line-110"></span><span>            </span><span class="hs-comment">-- There is a type condition, but it is just the type of the</span><span>
</span><span id="line-111"></span><span>            </span><span class="hs-comment">-- selection set; the fragment trivially applies.</span><span>
</span><span id="line-112"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689408591"><span class="hs-identifier hs-var">typeName</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; t Name -&gt; Bool
forall (t :: * -&gt; *) a. (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool
</span><span class="hs-operator hs-var">`elem`</span></span><span> </span><span class="annot"><span class="annottext">t Name
</span><a href="#local-6989586621689408607"><span class="hs-identifier hs-var">objectTypeNames</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">InlineFragment NoFragments Variable
-&gt; m [Field NoFragments Variable]
</span><a href="#local-6989586621689408592"><span class="hs-identifier hs-var">flattenInlineFragment</span></a></span><span> </span><span class="annot"><span class="annottext">InlineFragment NoFragments Variable
</span><a href="#local-6989586621689408596"><span class="hs-identifier hs-var">fragment</span></a></span><span>
</span><span id="line-113"></span><span>            </span><span class="hs-comment">-- Otherwise, the fragment must not apply, because we do not currently</span><span>
</span><span id="line-114"></span><span>            </span><span class="hs-comment">-- support interfaces or unions. According to the GraphQL spec, it is</span><span>
</span><span id="line-115"></span><span>            </span><span class="hs-comment">-- an *error* to select a fragment that cannot possibly apply to the</span><span>
</span><span id="line-116"></span><span>            </span><span class="hs-comment">-- given type; see</span><span>
</span><span id="line-117"></span><span>            </span><span class="hs-comment">-- http://spec.graphql.org/June2018/#sec-Fragment-spread-is-possible.</span><span>
</span><span id="line-118"></span><span>            </span><span class="hs-comment">-- Therefore, we raise an error.</span><span>
</span><span id="line-119"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Field NoFragments Variable] -&gt; m [Field NoFragments Variable]
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-120"></span><span>    </span><span class="hs-comment">{- parseError $ &quot;illegal type condition in fragment; type &quot;
      &lt;&gt; typeName &lt;&lt;&gt; &quot; is unrelated to any of the types &quot; &lt;&gt;
      Text.intercalate &quot;, &quot; (fmap dquoteTxt (toList objectTypeNames))
    -}</span><span>
</span><span id="line-124"></span><span>
</span><span id="line-125"></span><span>    </span><span id="local-6989586621689408592"><span class="annot"><span class="annottext">flattenInlineFragment :: InlineFragment NoFragments Variable
-&gt; m [Field NoFragments Variable]
</span><a href="#local-6989586621689408592"><span class="hs-identifier hs-var hs-var">flattenInlineFragment</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">InlineFragment</span></span><span> </span><span class="hs-special">{</span><span id="local-6989586621689408588"><span class="annot"><span class="annottext">SelectionSet NoFragments Variable
_ifSelectionSet :: forall (frag :: * -&gt; *) var.
InlineFragment frag var -&gt; SelectionSet frag var
_ifSelectionSet :: SelectionSet NoFragments Variable
</span><span class="hs-identifier hs-var hs-var">_ifSelectionSet</span></span></span><span class="hs-special">}</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-126"></span><span>      </span><span class="annot"><span class="annottext">t Name
-&gt; SelectionSet NoFragments Variable
-&gt; m [Field NoFragments Variable]
forall (m :: * -&gt; *) (t :: * -&gt; *).
(MonadParse m, Foldable t) =&gt;
t Name
-&gt; SelectionSet NoFragments Variable
-&gt; m [Field NoFragments Variable]
</span><a href="Hasura.GraphQL.Parser.Collect.html#flattenSelectionSet"><span class="hs-identifier hs-var">flattenSelectionSet</span></a></span><span> </span><span class="annot"><span class="annottext">t Name
</span><a href="#local-6989586621689408607"><span class="hs-identifier hs-var">objectTypeNames</span></a></span><span> </span><span class="annot"><span class="annottext">SelectionSet NoFragments Variable
</span><a href="#local-6989586621689408588"><span class="hs-identifier hs-var">_ifSelectionSet</span></a></span><span>
</span><span id="line-127"></span><span>
</span><span id="line-128"></span><span>    </span><span id="local-6989586621689408600"><span class="annot"><span class="annottext">applyInclusionDirectives :: ExecutableDirectiveLocation
-&gt; [Directive Variable] -&gt; m [a] -&gt; m [a]
</span><a href="#local-6989586621689408600"><span class="hs-identifier hs-var hs-var">applyInclusionDirectives</span></a></span></span><span> </span><span id="local-6989586621689408586"><span class="annot"><span class="annottext">ExecutableDirectiveLocation
</span><a href="#local-6989586621689408586"><span class="hs-identifier hs-var">location</span></a></span></span><span> </span><span id="local-6989586621689408585"><span class="annot"><span class="annottext">[Directive Variable]
</span><a href="#local-6989586621689408585"><span class="hs-identifier hs-var">directives</span></a></span></span><span> </span><span id="local-6989586621689408584"><span class="annot"><span class="annottext">m [a]
</span><a href="#local-6989586621689408584"><span class="hs-identifier hs-var">continue</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-129"></span><span>      </span><span id="local-6989586621689408583"><span class="annot"><span class="annottext">DirectiveMap
</span><a href="#local-6989586621689408583"><span class="hs-identifier hs-var">dirMap</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[Directive Any m]
-&gt; DirectiveLocation -&gt; [Directive Variable] -&gt; m DirectiveMap
forall origin (m :: * -&gt; *).
MonadParse m =&gt;
[Directive origin m]
-&gt; DirectiveLocation -&gt; [Directive Variable] -&gt; m DirectiveMap
</span><a href="Hasura.GraphQL.Parser.Directives.html#parseDirectives"><span class="hs-identifier hs-var">parseDirectives</span></a></span><span> </span><span class="annot"><span class="annottext">[Directive Any m]
forall (m :: * -&gt; *) origin. MonadParse m =&gt; [Directive origin m]
</span><a href="Hasura.GraphQL.Parser.Directives.html#inclusionDirectives"><span class="hs-identifier hs-var">inclusionDirectives</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ExecutableDirectiveLocation -&gt; DirectiveLocation
</span><span class="hs-identifier hs-var">DLExecutable</span></span><span> </span><span class="annot"><span class="annottext">ExecutableDirectiveLocation
</span><a href="#local-6989586621689408586"><span class="hs-identifier hs-var">location</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Directive Variable]
</span><a href="#local-6989586621689408585"><span class="hs-identifier hs-var">directives</span></a></span><span>
</span><span id="line-130"></span><span>      </span><span id="local-6989586621689408579"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621689408579"><span class="hs-identifier hs-var">shouldSkip</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">DirectiveMap
-&gt; DirectiveKey Bool -&gt; (Maybe Bool -&gt; m Bool) -&gt; m Bool
forall a (m :: * -&gt; *) b.
DirectiveMap -&gt; DirectiveKey a -&gt; (Maybe a -&gt; m b) -&gt; m b
</span><a href="Hasura.GraphQL.Parser.Directives.html#withDirective"><span class="hs-identifier hs-var">withDirective</span></a></span><span> </span><span class="annot"><span class="annottext">DirectiveMap
</span><a href="#local-6989586621689408583"><span class="hs-identifier hs-var">dirMap</span></a></span><span> </span><span class="annot"><span class="annottext">DirectiveKey Bool
</span><a href="Hasura.GraphQL.Parser.Directives.html#skip"><span class="hs-identifier hs-var">skip</span></a></span><span> </span><span class="annot"><span class="annottext">((Maybe Bool -&gt; m Bool) -&gt; m Bool)
-&gt; (Maybe Bool -&gt; m Bool) -&gt; m Bool
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; m Bool
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; m Bool) -&gt; (Maybe Bool -&gt; Bool) -&gt; Maybe Bool -&gt; m Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Maybe Bool -&gt; Bool
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-131"></span><span>      </span><span id="local-6989586621689408576"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621689408576"><span class="hs-identifier hs-var">shouldInclude</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">DirectiveMap
-&gt; DirectiveKey Bool -&gt; (Maybe Bool -&gt; m Bool) -&gt; m Bool
forall a (m :: * -&gt; *) b.
DirectiveMap -&gt; DirectiveKey a -&gt; (Maybe a -&gt; m b) -&gt; m b
</span><a href="Hasura.GraphQL.Parser.Directives.html#withDirective"><span class="hs-identifier hs-var">withDirective</span></a></span><span> </span><span class="annot"><span class="annottext">DirectiveMap
</span><a href="#local-6989586621689408583"><span class="hs-identifier hs-var">dirMap</span></a></span><span> </span><span class="annot"><span class="annottext">DirectiveKey Bool
</span><a href="Hasura.GraphQL.Parser.Directives.html#include"><span class="hs-identifier hs-var">include</span></a></span><span> </span><span class="annot"><span class="annottext">((Maybe Bool -&gt; m Bool) -&gt; m Bool)
-&gt; (Maybe Bool -&gt; m Bool) -&gt; m Bool
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; m Bool
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; m Bool) -&gt; (Maybe Bool -&gt; Bool) -&gt; Maybe Bool -&gt; m Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Maybe Bool -&gt; Bool
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-132"></span><span>      </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621689408576"><span class="hs-identifier hs-var">shouldInclude</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621689408579"><span class="hs-identifier hs-var">shouldSkip</span></a></span><span>
</span><span id="line-133"></span><span>        </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">m [a]
</span><a href="#local-6989586621689408584"><span class="hs-identifier hs-var">continue</span></a></span><span>
</span><span id="line-134"></span><span>        </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">[a] -&gt; m [a]
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-135"></span><span>
</span><span id="line-136"></span><span class="hs-comment">-- | Merges fields according to the rules in the GraphQL specification, specifically</span><span>
</span><span id="line-137"></span><span class="hs-comment">-- &lt;&#167; 5.3.2 Field Selection Merging http://spec.graphql.org/June2018/#sec-Field-Selection-Merging&gt;.</span><span>
</span><span id="line-138"></span><span id="local-6989586621689408714"><span id="local-6989586621689408716"><span class="annot"><a href="Hasura.GraphQL.Parser.Collect.html#mergeFields"><span class="hs-identifier hs-type">mergeFields</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-139"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Class.Parse.html#MonadParse"><span class="hs-identifier hs-type">MonadParse</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689408716"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621689408714"><span class="hs-identifier hs-type">var</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-140"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Field</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NoFragments</span></span><span> </span><span class="annot"><a href="#local-6989586621689408714"><span class="hs-identifier hs-type">var</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-141"></span><span>  </span><span class="annot"><a href="#local-6989586621689408716"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">InsOrdHashMap</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Field</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NoFragments</span></span><span> </span><span class="annot"><a href="#local-6989586621689408714"><span class="hs-identifier hs-type">var</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-142"></span><span id="mergeFields"><span class="annot"><span class="annottext">mergeFields :: [Field NoFragments var]
-&gt; m (InsOrdHashMap Name (Field NoFragments var))
</span><a href="Hasura.GraphQL.Parser.Collect.html#mergeFields"><span class="hs-identifier hs-var hs-var">mergeFields</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(InsOrdHashMap Name (Field NoFragments var)
 -&gt; Field NoFragments var
 -&gt; m (InsOrdHashMap Name (Field NoFragments var)))
-&gt; InsOrdHashMap Name (Field NoFragments var)
-&gt; [Field NoFragments var]
-&gt; m (InsOrdHashMap Name (Field NoFragments var))
forall (t :: * -&gt; *) (m :: * -&gt; *) b a.
(Foldable t, Monad m) =&gt;
(b -&gt; a -&gt; m b) -&gt; b -&gt; t a -&gt; m b
</span><span class="hs-identifier hs-var">foldM</span></span><span> </span><span class="annot"><span class="annottext">InsOrdHashMap Name (Field NoFragments var)
-&gt; Field NoFragments var
-&gt; m (InsOrdHashMap Name (Field NoFragments var))
forall (f :: * -&gt; *) var (frag :: * -&gt; *).
(MonadParse f, Eq var) =&gt;
InsOrdHashMap Name (Field frag var)
-&gt; Field frag var -&gt; f (InsOrdHashMap Name (Field frag var))
</span><a href="#local-6989586621689408572"><span class="hs-identifier hs-var">addField</span></a></span><span> </span><span class="annot"><span class="annottext">InsOrdHashMap Name (Field NoFragments var)
forall k v. InsOrdHashMap k v
</span><span class="hs-identifier hs-var">OMap.empty</span></span><span>
</span><span id="line-143"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-144"></span><span>    </span><span id="local-6989586621689408572"><span class="annot"><span class="annottext">addField :: InsOrdHashMap Name (Field frag var)
-&gt; Field frag var -&gt; f (InsOrdHashMap Name (Field frag var))
</span><a href="#local-6989586621689408572"><span class="hs-identifier hs-var hs-var">addField</span></a></span></span><span> </span><span id="local-6989586621689408570"><span class="annot"><span class="annottext">InsOrdHashMap Name (Field frag var)
</span><a href="#local-6989586621689408570"><span class="hs-identifier hs-var">fields</span></a></span></span><span> </span><span id="local-6989586621689408569"><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408569"><span class="hs-identifier hs-var">newField</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Name
-&gt; InsOrdHashMap Name (Field frag var) -&gt; Maybe (Field frag var)
forall k v. (Eq k, Hashable k) =&gt; k -&gt; InsOrdHashMap k v -&gt; Maybe v
</span><span class="hs-identifier hs-var">OMap.lookup</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689408567"><span class="hs-identifier hs-var">alias</span></a></span><span> </span><span class="annot"><span class="annottext">InsOrdHashMap Name (Field frag var)
</span><a href="#local-6989586621689408570"><span class="hs-identifier hs-var">fields</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-145"></span><span>      </span><span class="annot"><span class="annottext">Maybe (Field frag var)
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-146"></span><span>        </span><span class="annot"><span class="annottext">InsOrdHashMap Name (Field frag var)
-&gt; f (InsOrdHashMap Name (Field frag var))
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(InsOrdHashMap Name (Field frag var)
 -&gt; f (InsOrdHashMap Name (Field frag var)))
-&gt; InsOrdHashMap Name (Field frag var)
-&gt; f (InsOrdHashMap Name (Field frag var))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$!</span></span><span> </span><span class="annot"><span class="annottext">Name
-&gt; Field frag var
-&gt; InsOrdHashMap Name (Field frag var)
-&gt; InsOrdHashMap Name (Field frag var)
forall k v.
(Eq k, Hashable k) =&gt;
k -&gt; v -&gt; InsOrdHashMap k v -&gt; InsOrdHashMap k v
</span><span class="hs-identifier hs-var">OMap.insert</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689408567"><span class="hs-identifier hs-var">alias</span></a></span><span> </span><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408569"><span class="hs-identifier hs-var">newField</span></a></span><span> </span><span class="annot"><span class="annottext">InsOrdHashMap Name (Field frag var)
</span><a href="#local-6989586621689408570"><span class="hs-identifier hs-var">fields</span></a></span><span>
</span><span id="line-147"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621689408564"><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408564"><span class="hs-identifier hs-var">oldField</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-148"></span><span>        </span><span id="local-6989586621689408563"><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408563"><span class="hs-identifier hs-var">mergedField</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Field frag var -&gt; Field frag var -&gt; f (Field frag var)
forall (m :: * -&gt; *) var (frag :: * -&gt; *).
(MonadParse m, Eq var) =&gt;
Name -&gt; Field frag var -&gt; Field frag var -&gt; m (Field frag var)
</span><a href="#local-6989586621689408562"><span class="hs-identifier hs-var">mergeField</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689408567"><span class="hs-identifier hs-var">alias</span></a></span><span> </span><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408564"><span class="hs-identifier hs-var">oldField</span></a></span><span> </span><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408569"><span class="hs-identifier hs-var">newField</span></a></span><span>
</span><span id="line-149"></span><span>        </span><span class="annot"><span class="annottext">InsOrdHashMap Name (Field frag var)
-&gt; f (InsOrdHashMap Name (Field frag var))
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(InsOrdHashMap Name (Field frag var)
 -&gt; f (InsOrdHashMap Name (Field frag var)))
-&gt; InsOrdHashMap Name (Field frag var)
-&gt; f (InsOrdHashMap Name (Field frag var))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$!</span></span><span> </span><span class="annot"><span class="annottext">Name
-&gt; Field frag var
-&gt; InsOrdHashMap Name (Field frag var)
-&gt; InsOrdHashMap Name (Field frag var)
forall k v.
(Eq k, Hashable k) =&gt;
k -&gt; v -&gt; InsOrdHashMap k v -&gt; InsOrdHashMap k v
</span><span class="hs-identifier hs-var">OMap.insert</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689408567"><span class="hs-identifier hs-var">alias</span></a></span><span> </span><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408563"><span class="hs-identifier hs-var">mergedField</span></a></span><span> </span><span class="annot"><span class="annottext">InsOrdHashMap Name (Field frag var)
</span><a href="#local-6989586621689408570"><span class="hs-identifier hs-var">fields</span></a></span><span>
</span><span id="line-150"></span><span>      </span><span class="hs-keyword">where</span><span>
</span><span id="line-151"></span><span>        </span><span id="local-6989586621689408567"><span class="annot"><span class="annottext">alias :: Name
</span><a href="#local-6989586621689408567"><span class="hs-identifier hs-var hs-var">alias</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Maybe Name -&gt; Name
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Field frag var -&gt; Name
forall (frag :: * -&gt; *) var. Field frag var -&gt; Name
</span><span class="hs-identifier hs-var hs-var">_fName</span></span><span> </span><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408569"><span class="hs-identifier hs-var">newField</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Field frag var -&gt; Maybe Name
forall (frag :: * -&gt; *) var. Field frag var -&gt; Maybe Name
</span><span class="hs-identifier hs-var hs-var">_fAlias</span></span><span> </span><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408569"><span class="hs-identifier hs-var">newField</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-152"></span><span>
</span><span id="line-153"></span><span>    </span><span id="local-6989586621689408562"><span class="annot"><span class="annottext">mergeField :: Name -&gt; Field frag var -&gt; Field frag var -&gt; m (Field frag var)
</span><a href="#local-6989586621689408562"><span class="hs-identifier hs-var hs-var">mergeField</span></a></span></span><span> </span><span id="local-6989586621689408559"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689408559"><span class="hs-identifier hs-var">alias</span></a></span></span><span> </span><span id="local-6989586621689408558"><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408558"><span class="hs-identifier hs-var">oldField</span></a></span></span><span> </span><span id="local-6989586621689408557"><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408557"><span class="hs-identifier hs-var">newField</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-154"></span><span>      </span><span class="annot"><span class="annottext">Bool -&gt; m () -&gt; m ()
forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">unless</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Field frag var -&gt; Name
forall (frag :: * -&gt; *) var. Field frag var -&gt; Name
</span><span class="hs-identifier hs-var hs-var">_fName</span></span><span> </span><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408558"><span class="hs-identifier hs-var">oldField</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Field frag var -&gt; Name
forall (frag :: * -&gt; *) var. Field frag var -&gt; Name
</span><span class="hs-identifier hs-var hs-var">_fName</span></span><span> </span><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408557"><span class="hs-identifier hs-var">newField</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(m () -&gt; m ()) -&gt; m () -&gt; m ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-155"></span><span>        </span><span class="annot"><span class="annottext">ErrorMessage -&gt; m ()
forall (m :: * -&gt; *) a. MonadParse m =&gt; ErrorMessage -&gt; m a
</span><a href="Hasura.GraphQL.Parser.Class.Parse.html#parseError"><span class="hs-identifier hs-var">parseError</span></a></span><span> </span><span class="annot"><span class="annottext">(ErrorMessage -&gt; m ()) -&gt; ErrorMessage -&gt; m ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-156"></span><span>          </span><span class="annot"><span class="annottext">ErrorMessage
</span><span class="hs-string">&quot;selection of both &quot;</span></span><span> </span><span class="annot"><span class="annottext">ErrorMessage -&gt; ErrorMessage -&gt; ErrorMessage
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; ErrorMessage
forall a. ToErrorValue a =&gt; a -&gt; ErrorMessage
</span><a href="../file:///workdir/dist-newstyle/build/x86_64-linux/ghc-8.10.7/hasura-error-message-1.0.0/opt/doc/html/hasura-error-message/src"><span class="hs-identifier hs-var">toErrorValue</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Field frag var -&gt; Name
forall (frag :: * -&gt; *) var. Field frag var -&gt; Name
</span><span class="hs-identifier hs-var hs-var">_fName</span></span><span> </span><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408558"><span class="hs-identifier hs-var">oldField</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ErrorMessage -&gt; ErrorMessage -&gt; ErrorMessage
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">ErrorMessage
</span><span class="hs-string">&quot; and &quot;</span></span><span>
</span><span id="line-157"></span><span>            </span><span class="annot"><span class="annottext">ErrorMessage -&gt; ErrorMessage -&gt; ErrorMessage
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; ErrorMessage
forall a. ToErrorValue a =&gt; a -&gt; ErrorMessage
</span><a href="../file:///workdir/dist-newstyle/build/x86_64-linux/ghc-8.10.7/hasura-error-message-1.0.0/opt/doc/html/hasura-error-message/src"><span class="hs-identifier hs-var">toErrorValue</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Field frag var -&gt; Name
forall (frag :: * -&gt; *) var. Field frag var -&gt; Name
</span><span class="hs-identifier hs-var hs-var">_fName</span></span><span> </span><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408557"><span class="hs-identifier hs-var">newField</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-158"></span><span>            </span><span class="annot"><span class="annottext">ErrorMessage -&gt; ErrorMessage -&gt; ErrorMessage
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">ErrorMessage
</span><span class="hs-string">&quot; specify the same response name, &quot;</span></span><span>
</span><span id="line-159"></span><span>            </span><span class="annot"><span class="annottext">ErrorMessage -&gt; ErrorMessage -&gt; ErrorMessage
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; ErrorMessage
forall a. ToErrorValue a =&gt; a -&gt; ErrorMessage
</span><a href="../file:///workdir/dist-newstyle/build/x86_64-linux/ghc-8.10.7/hasura-error-message-1.0.0/opt/doc/html/hasura-error-message/src"><span class="hs-identifier hs-var">toErrorValue</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689408559"><span class="hs-identifier hs-var">alias</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-160"></span><span>
</span><span id="line-161"></span><span>      </span><span class="annot"><span class="annottext">Bool -&gt; m () -&gt; m ()
forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">unless</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Field frag var -&gt; HashMap Name (Value var)
forall (frag :: * -&gt; *) var.
Field frag var -&gt; HashMap Name (Value var)
</span><span class="hs-identifier hs-var hs-var">_fArguments</span></span><span> </span><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408558"><span class="hs-identifier hs-var">oldField</span></a></span><span> </span><span class="annot"><span class="annottext">HashMap Name (Value var) -&gt; HashMap Name (Value var) -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Field frag var -&gt; HashMap Name (Value var)
forall (frag :: * -&gt; *) var.
Field frag var -&gt; HashMap Name (Value var)
</span><span class="hs-identifier hs-var hs-var">_fArguments</span></span><span> </span><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408557"><span class="hs-identifier hs-var">newField</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(m () -&gt; m ()) -&gt; m () -&gt; m ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-162"></span><span>        </span><span class="annot"><span class="annottext">ErrorMessage -&gt; m ()
forall (m :: * -&gt; *) a. MonadParse m =&gt; ErrorMessage -&gt; m a
</span><a href="Hasura.GraphQL.Parser.Class.Parse.html#parseError"><span class="hs-identifier hs-var">parseError</span></a></span><span> </span><span class="annot"><span class="annottext">(ErrorMessage -&gt; m ()) -&gt; ErrorMessage -&gt; m ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-163"></span><span>          </span><span class="annot"><span class="annottext">ErrorMessage
</span><span class="hs-string">&quot;inconsistent arguments between multiple selections of field &quot;</span></span><span> </span><span class="annot"><span class="annottext">ErrorMessage -&gt; ErrorMessage -&gt; ErrorMessage
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; ErrorMessage
forall a. ToErrorValue a =&gt; a -&gt; ErrorMessage
</span><a href="../file:///workdir/dist-newstyle/build/x86_64-linux/ghc-8.10.7/hasura-error-message-1.0.0/opt/doc/html/hasura-error-message/src"><span class="hs-identifier hs-var">toErrorValue</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Field frag var -&gt; Name
forall (frag :: * -&gt; *) var. Field frag var -&gt; Name
</span><span class="hs-identifier hs-var hs-var">_fName</span></span><span> </span><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408558"><span class="hs-identifier hs-var">oldField</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-164"></span><span>
</span><span id="line-165"></span><span>      </span><span class="annot"><span class="annottext">Field frag var -&gt; m (Field frag var)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-166"></span><span>        </span><span class="annot"><span class="annottext">(Field frag var -&gt; m (Field frag var))
-&gt; Field frag var -&gt; m (Field frag var)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$!</span></span><span> </span><span class="annot"><span class="annottext">Field :: forall (frag :: * -&gt; *) var.
Maybe Name
-&gt; Name
-&gt; HashMap Name (Value var)
-&gt; [Directive var]
-&gt; SelectionSet frag var
-&gt; Field frag var
</span><span class="hs-identifier hs-type">Field</span></span><span>
</span><span id="line-167"></span><span>          </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">_fAlias :: Maybe Name
</span><span class="hs-identifier hs-var">_fAlias</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Maybe Name
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689408559"><span class="hs-identifier hs-var">alias</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-168"></span><span>            </span><span class="annot"><span class="annottext">_fName :: Name
</span><span class="hs-identifier hs-var">_fName</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Field frag var -&gt; Name
forall (frag :: * -&gt; *) var. Field frag var -&gt; Name
</span><span class="hs-identifier hs-var hs-var">_fName</span></span><span> </span><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408558"><span class="hs-identifier hs-var">oldField</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-169"></span><span>            </span><span class="annot"><span class="annottext">_fArguments :: HashMap Name (Value var)
</span><span class="hs-identifier hs-var">_fArguments</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Field frag var -&gt; HashMap Name (Value var)
forall (frag :: * -&gt; *) var.
Field frag var -&gt; HashMap Name (Value var)
</span><span class="hs-identifier hs-var hs-var">_fArguments</span></span><span> </span><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408558"><span class="hs-identifier hs-var">oldField</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-170"></span><span>            </span><span class="annot"><span class="annottext">_fDirectives :: [Directive var]
</span><span class="hs-identifier hs-var">_fDirectives</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Field frag var -&gt; [Directive var]
forall (frag :: * -&gt; *) var. Field frag var -&gt; [Directive var]
</span><span class="hs-identifier hs-var hs-var">_fDirectives</span></span><span> </span><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408558"><span class="hs-identifier hs-var">oldField</span></a></span><span> </span><span class="annot"><span class="annottext">[Directive var] -&gt; [Directive var] -&gt; [Directive var]
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Field frag var -&gt; [Directive var]
forall (frag :: * -&gt; *) var. Field frag var -&gt; [Directive var]
</span><span class="hs-identifier hs-var hs-var">_fDirectives</span></span><span> </span><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408557"><span class="hs-identifier hs-var">newField</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-171"></span><span>            </span><span class="hs-comment">-- see Note [Lazily merge selection sets]</span><span>
</span><span id="line-172"></span><span>            </span><span class="annot"><span class="annottext">_fSelectionSet :: SelectionSet frag var
</span><span class="hs-identifier hs-var">_fSelectionSet</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Field frag var -&gt; SelectionSet frag var
forall (frag :: * -&gt; *) var.
Field frag var -&gt; SelectionSet frag var
</span><span class="hs-identifier hs-var hs-var">_fSelectionSet</span></span><span> </span><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408558"><span class="hs-identifier hs-var">oldField</span></a></span><span> </span><span class="annot"><span class="annottext">SelectionSet frag var
-&gt; SelectionSet frag var -&gt; SelectionSet frag var
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Field frag var -&gt; SelectionSet frag var
forall (frag :: * -&gt; *) var.
Field frag var -&gt; SelectionSet frag var
</span><span class="hs-identifier hs-var hs-var">_fSelectionSet</span></span><span> </span><span class="annot"><span class="annottext">Field frag var
</span><a href="#local-6989586621689408557"><span class="hs-identifier hs-var">newField</span></a></span><span>
</span><span id="line-173"></span><span>          </span><span class="hs-special">}</span><span>
</span><span id="line-174"></span><span>
</span><span id="line-175"></span><span class="hs-comment">{- Note [Lazily merge selection sets]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Field merging is described in a recursive way in the GraphQL spec (&#167; 5.3.2 Field
Selection Merging http://spec.graphql.org/June2018/#sec-Field-Selection-Merging).
This makes sense: if fields have sub-selection sets, they should be recursively
merged. For example, suppose we have the following selection set:

    {
      field1 {
        field2 {
          field3
        }
        field5
      }
      field1 {
        field2 {
          field4
        }
        field5
      }
    }

After a single level of merging, we&#8217;ll merge the two occurrences of field1
together to get:

    {
      field1 {
        field2 {
          field3
        }
        field5
        field2 {
          field4
        }
        field5
      }
    }

It would be natural to then merge the inner selection set, too, yielding:

    {
      field1 {
        field2 {
          field3
          field4
        }
        field5
      }
    }

But we don&#8217;t do this. Instead, we stop after the first level of merging, so
field1&#8217;s sub-selection set still has duplication. Why? Because recursively
merging fields would also require recursively flattening fragments, and
flattening fragments is tricky: it requires knowledge of type information.

Fortunately, this lazy approach to field merging is totally okay, because we
call collectFields (and therefore mergeFields) each time we parse a selection
set. Once we get to processing the sub-selection set of field1, we&#8217;ll call
collectFields again, and it will merge things the rest of the way. This is
consistent with the way the rest of our parsing system works, where parsers
interpret their own inputs on an as-needed basis. -}</span><span>
</span><span id="line-236"></span></pre></body></html>